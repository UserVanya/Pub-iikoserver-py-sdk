# coding: utf-8

"""
    iikoServer API

    API Server позволяет сделать интеграции, которые предназначены для работы с номенклатурой, отчетами, документами, данными сотрудников и приказами.   ### Ограничения и рекомендации - Запросы должны выполняться последовательно друг за другом - Запрашивайте данные за период не длиннее одного месяца, в идеале — за один день или неделю - Для OLAPv2-отчетов рекомендуется устанавливать build-summary=false - При построении OLAPv2-отчета рекомендуется использовать не более 7 полей - Перед выполнением запросов проверяйте их на демо сервере

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from datetime import datetime, timedelta
import unittest
import os
import hashlib
import asyncio
import json

from iikoserver_client.api.reference_data_api import ReferenceDataApi
from iikoserver_client.api.session_management_api import SessionManagementApi
from iikoserver_client import ApiClient
from iikoserver_client.configuration import Configuration
from iikoserver_client.api.documents_management_api import DocumentsManagementApi
from iikoserver_client.api.corporation_management_api import CorporationManagementApi
from iikoserver_client.api.nomenclature_management_api import NomenclatureManagementApi
from iikoserver_client.api.supplers_management_api import SupplersManagementApi
from iikoserver_client.models.production_document_xml import ProductionDocumentXml
from iikoserver_client.models.production_document_item_xml import ProductionDocumentItemXml
from iikoserver_client.models.production_document_xml_items import ProductionDocumentXmlItems
from iikoserver_client.models.sales_document_xml import SalesDocumentXml
from iikoserver_client.models.sales_document_item_xml import SalesDocumentItemXml
from iikoserver_client.models.sales_document_xml_items import SalesDocumentXmlItems
from iikoserver_client.models.incoming_inventory_xml import IncomingInventoryXml
from iikoserver_client.models.incoming_inventory_xml_items import IncomingInventoryXmlItems
from iikoserver_client.models.incoming_inventory_item_xml import IncomingInventoryItemXml
from iikoserver_client.models.document_status_enum import DocumentStatusEnum
from iikoserver_client.models.inventory_item_status_enum import InventoryItemStatusEnum
from iikoserver_client.models.request_result_dto_enum import RequestResultDtoEnum
from iikoserver_client.models.writeoff_document_dto import WriteoffDocumentDto
from iikoserver_client.models.writeoff_document_item_dto import WriteoffDocumentItemDto
from iikoserver_client.models.internal_transfer_dto import InternalTransferDto
from iikoserver_client.models.internal_transfer_item_dto import InternalTransferItemDto

class TestDocumentsManagementApi(unittest.IsolatedAsyncioTestCase):
    """DocumentsManagementApi unit test stubs"""

    async def asyncSetUp(self) -> None:
        # Read credentials from env variables or set them directly
        self.server_url = os.environ.get("IIKO_SERVER_URL", None)
        self.login = os.environ.get("IIKO_SERVER_LOGIN", None)  # Replace with your login
        self.password = os.environ.get("IIKO_SERVER_PASSWORD", None)  # Replace with your password
        self.password_hash = hashlib.sha1(self.password.encode()).hexdigest()
        
        # Create configuration
        self.config = Configuration(host=self.server_url, debug=True)
        
        # Create API client with context manager support
        self.client = ApiClient(configuration=self.config)
        self.test_good_id = "244079d3-3fa1-4479-96ef-e8183ed96de9"
        self.test_store_from_id = "1239d270-1bbe-f64f-b7ea-5f00518ef508"
        self.test_store_to_id = "e9e87d8d-c0c4-4d85-976b-3606f1fe63a5"
        self.test_account_id = self.test_store_from_id
        
        self.session_api = SessionManagementApi(api_client=self.client)
        self.corporates_api = CorporationManagementApi(api_client=self.client)
        self.nomenclature_api = NomenclatureManagementApi(api_client=self.client)
        self.suppliers_api = SupplersManagementApi(api_client=self.client)
        self.reference_api = ReferenceDataApi(api_client=self.client)
        await self.session_api.auth_post(login=self.login, var_pass=self.password_hash)
        self.api = DocumentsManagementApi(api_client=self.client)

    async def asyncTearDown(self) -> None:
        # Make sure to properly close all connections
        try:
            await self.session_api.logout_post()
        except Exception as e:
            print(f"Warning: logout failed: {e}")
        
        # Ensure client is closed properly
        await self.client.close()
        
        # Give event loop time to cleanup resources
        await asyncio.sleep(0.1)

    async def test_documents_import_production_document_post(self) -> None:
        """Test case for documents_import_production_document_post

        Загрузка акта приготовления
        """
        try:
            # Get product details for the test
            nomenclature_response = await self.nomenclature_api.v2_entities_products_list_get(ids=[self.test_good_id])
            test_product = next((product for product in nomenclature_response if product.name == "Шампанка"), None)
            
            if test_product is None:
                self.skipTest("Test product not found in nomenclature")
            
            # Create production document with valid data
            production_document_xml = ProductionDocumentXml(
                items=ProductionDocumentXmlItems(
                    item=[
                        ProductionDocumentItemXml(
                            amount=5.0,
                            product=test_product.id,
                            num=1,
                            container_id=None,
                            amount_unit=test_product.main_unit,
                        ),
                        ProductionDocumentItemXml(
                            amount=3.0,
                            product=test_product.id,
                            num=2,
                            container_id=None,
                            amount_unit=test_product.main_unit,
                        ),
                    ]
                ),
                comment="Тестовый акт приготовления - успешный случай",
                document_number=f"PROD-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
                date_incoming=datetime.now().strftime("%Y-%m-%dT%H:%M:%S"),
                store_to=self.test_store_to_id,
                store_from=self.test_store_from_id,
            )
            
            print("Production Document XML:")
            print(json.dumps(production_document_xml.to_dict(), indent=4, ensure_ascii=False))
            
            # Import the production document
            doc_val_result = await self.api.documents_import_production_document_post(
                production_document_xml=production_document_xml
            )
            
            print("Import Result:")
            print(doc_val_result.model_dump_json(indent=4))
            
            # Validate response structure
            self.assertIsNotNone(doc_val_result)
            self.assertIsNotNone(doc_val_result.valid)
            
            # In successful case, expect valid=True or at least no exception
            if hasattr(doc_val_result, 'valid'):
                self.assertTrue(doc_val_result.valid or doc_val_result.valid is None)
                
        except Exception as e:
            self.fail(f"Documents import production document POST failed with error: {str(e)}")

    async def test_documents_import_sales_document_post(self) -> None:
        """Test case for documents_import_sales_document_post

        Загрузка акта реализации
        """
        try:
            # Get product details for the test
            nomenclature_response = await self.nomenclature_api.v2_entities_products_list_get(ids=[self.test_good_id])
            test_product = next((product for product in nomenclature_response if product.name == "Шампанка"), None)
            
            if test_product is None:
                self.skipTest("Test product not found in nomenclature")
            
            # Create sales document with minimal data
            sales_document_xml = SalesDocumentXml(
                items=SalesDocumentXmlItems(
                    item=[
                        SalesDocumentItemXml(
                            amount=1.0,
                            product_id=test_product.id,
                            store_id=self.test_store_to_id,
                            sum=50.00  # Required field
                        ),
                    ]
                ),
                date_incoming=datetime.now()
            )
            
            print("Minimal Sales Document XML:")
            print(sales_document_xml.model_dump_json(indent=4))
            
            # Import the sales document
            doc_val_result = await self.api.documents_import_sales_document_post(
                sales_document_xml=sales_document_xml
            )
            
            print("Minimal Sales Import Result:")
            print(doc_val_result.model_dump_json(indent=4))
            
            # Validate response structure
            self.assertIsNotNone(doc_val_result)
            
        except Exception as e:
            # For minimal data, we might expect validation errors, but should not crash
            print(f"Expected validation error for minimal data: {str(e)}")
            # Ensure it's a validation error, not a system error
            self.assertIn("validation", str(e).lower())

    async def test_documents_import_incoming_inventory_post(self) -> None:
        """Test case for documents_import_incoming_inventory_post

        Загрузка инвентаризации
        """
        try:
            # Create incoming inventory document with valid data
            incoming_inventory_xml = IncomingInventoryXml(
                items=IncomingInventoryXmlItems(
                    item=[
                        IncomingInventoryItemXml(
                            status=InventoryItemStatusEnum.SAVE,
                            product_id=self.test_good_id,
                            amount_container=5.0,
                            comment="Подсчитано: 5 единиц"
                        )
                    ]
                ),
                document_number=f"INV-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
                date_incoming=datetime.now(),
                status=DocumentStatusEnum.PROCESSED,
                store_id=self.test_store_to_id,
                comment="Тестовая инвентаризация - успешный случай",
                account_surplus_code="5.10",
                account_shortage_code="5.09"
            )
            
            print("Incoming Inventory XML:")
            print(incoming_inventory_xml.model_dump_json(indent=4))
            
            # Import the incoming inventory document
            inventory_result = await self.api.documents_import_incoming_inventory_post(
                incoming_inventory_xml=incoming_inventory_xml
            )
            
            print("Incoming Inventory Import Result:")
            print(inventory_result.model_dump_json(indent=4))
            
            # Validate response structure
            self.assertIsNotNone(inventory_result)
            self.assertIsNotNone(inventory_result.valid)
            self.assertIsNotNone(inventory_result.document_number)
            
            # Check that result has expected structure
            if hasattr(inventory_result, 'valid'):
                print(f"Validation result: {inventory_result.valid}")
            if hasattr(inventory_result, 'store') and inventory_result.store:
                print(f"Store: {inventory_result.store.name} (ID: {inventory_result.store.id})")
            if hasattr(inventory_result, 'items') and inventory_result.items and inventory_result.items.item:
                print(f"Items processed: {len(inventory_result.items.item)}")
                
        except Exception as e:
            self.fail(f"Documents import incoming inventory POST failed with error: {str(e)}")

    async def test_documents_check_incoming_inventory_post(self) -> None:
        """Test case for documents_check_incoming_inventory_post

        Получение результатов инвентаризации до ее проведения
        """
        try:
            # Create incoming inventory document for checking (similar to import but for validation)
            incoming_inventory_xml = IncomingInventoryXml(
                items=IncomingInventoryXmlItems(
                    item=[
                        IncomingInventoryItemXml(
                            status=InventoryItemStatusEnum.SAVE,
                            product_id=self.test_good_id,
                            amount_container=5.0,
                            comment="Предварительный подсчет: 5 единиц"
                        )
                    ]
                ),
                document_number=f"CHK-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
                date_incoming=datetime.now(),
                status=DocumentStatusEnum.PROCESSED,
                store_id=self.test_store_to_id,
                comment="Тестовая проверка инвентаризации - получение результатов до проведения",
                account_surplus_code="5.10",
                account_shortage_code="5.09"
            )
            
            print("Check Incoming Inventory XML:")
            print(incoming_inventory_xml.model_dump_json(indent=4))
            
            # Check the incoming inventory document (get results before actual processing)
            check_result = await self.api.documents_check_incoming_inventory_post(
                incoming_inventory_xml=incoming_inventory_xml
            )
            
            print("Check Incoming Inventory Result:")
            print(check_result.model_dump_json(indent=4))
            
            # Validate response structure for check operation
            self.assertIsNotNone(check_result)
            self.assertIsNotNone(check_result.valid)
            self.assertIsNotNone(check_result.document_number)
            
            # Check that result has expected structure specific to inventory validation
            if hasattr(check_result, 'valid'):
                print(f"Validation result: {check_result.valid}")
            if hasattr(check_result, 'store') and check_result.store:
                print(f"Store: {check_result.store.name} (ID: {check_result.store.id})")
            if hasattr(check_result, 'items') and check_result.items and check_result.items.item:
                print(f"Items checked: {len(check_result.items.item)}")
                for item in check_result.items.item:
                    if hasattr(item, 'product') and item.product:
                        print(f"Product: {item.product.name} (ID: {item.product.id})")
                        print(f"Expected amount: {item.expected_amount}")
                        print(f"Expected sum: {item.expected_sum}")
                        print(f"Actual amount: {item.actual_amount}")
                        print(f"Difference amount: {item.difference_amount}")
                        print(f"Difference sum: {item.difference_sum}")
            
            # The check operation should return detailed inventory calculations
            if hasattr(check_result, 'items') and check_result.items and check_result.items.item:
                for item in check_result.items.item:
                    # These fields are specific to inventory validation result
                    self.assertIsNotNone(item.expected_amount)
                    self.assertIsNotNone(item.expected_sum)
                    self.assertIsNotNone(item.actual_amount)
                    self.assertIsNotNone(item.difference_amount)
                    self.assertIsNotNone(item.difference_sum)
                
        except Exception as e:
            self.fail(f"Documents check incoming inventory POST failed with error: {str(e)}")

    async def test_v2_documents_writeoff_get(self) -> None:
        """Test case for v2_documents_writeoff_get

        Выгрузка документов списания
        """
        try:
            # This should be the structure for v2 response
            # In the actual test, we would call: 
            writeoff_result = await self.api.v2_documents_writeoff_get(
                date_from=(datetime.now() - timedelta(days=30)).date(), 
                date_to=datetime.now().date()
            )
            
            self.assertEqual(writeoff_result.result, RequestResultDtoEnum.SUCCESS)
            
        except Exception as e:
            self.fail(f"V2 documents writeoff GET failed with error: {str(e)}")

    async def test_v2_documents_writeoff_post(self) -> None:
        """Test case for v2_documents_writeoff_post

        Создание/редактирование документа списания
        """
        try:
            # Create a writeoff document with the v2 API structure
            writeoff_document = WriteoffDocumentDto(
                dateIncoming=datetime.now(),
                status=DocumentStatusEnum.NEW,
                comment="Тестовое списание через v2 API",
                storeId=self.test_store_to_id,
                accountId=self.test_account_id,
                items=[
                    WriteoffDocumentItemDto(
                        product_id=self.test_good_id,
                        amount=2.0
                    )
                ]
            )
            
            writeoff_result = await self.api.v2_documents_writeoff_post(
                writeoff_document_dto=writeoff_document
            )
            self.assertIsNotNone(writeoff_result)
            self.assertEqual(writeoff_result.result, RequestResultDtoEnum.SUCCESS)
        except Exception as e:
            self.fail(f"V2 documents writeoff POST failed with error: {str(e)}")

    async def test_v2_documents_writeoff_by_number_get(self) -> None:
        """Test case for v2_documents_writeoff_by_number_get
        
        Получение документа списания по номеру
        """
        try:
            writeoff_result = await self.api.v2_documents_writeoff_by_number_get(
                document_number="0001"
            )
            self.assertGreater(len(writeoff_result), 0)
        except Exception as e:
            self.fail(f"V2 documents writeoff by number GET failed with error: {str(e)}")

    async def test_v2_documents_writeoff_by_id_get(self) -> None:
        """Test case for v2_documents_writeoff_by_id_get
        
        Получение документа списания по ID
        """
        try:
            writeoff_result = await self.api.v2_documents_writeoff_by_id_get(
                id="91b2645a-2f97-1543-0197-a99407436730"
            )
            self.assertIsNotNone(writeoff_result)
        except Exception as e:
            self.fail(f"V2 documents writeoff by id GET failed with error: {str(e)}")

    async def test_v2_documents_internal_transfer_get(self) -> None:
        """Test case for v2_documents_internal_transfer_get

        Выгрузка документов внутреннего перемещения
        """
        try:
            internal_transfer_result = await self.api.v2_documents_internal_transfer_get(
                date_from=(datetime.now() - timedelta(days=30)).date(), 
                date_to=datetime.now().date()
            )
            
            self.assertEqual(internal_transfer_result.result, RequestResultDtoEnum.SUCCESS)
            
        except Exception as e:
            self.fail(f"V2 documents internal transfer GET failed with error: {str(e)}")

    async def test_v2_documents_internal_transfer_post(self) -> None:
        """Test case for v2_documents_internal_transfer_post

        Создание документа внутреннего перемещения
        """
        try:
            # Create an internal transfer document with the v2 API structure
            internal_transfer_document = InternalTransferDto(
                dateIncoming=datetime.now(),
                status=DocumentStatusEnum.NEW,
                comment="Тестовое внутреннее перемещение через v2 API",
                storeFromId=self.test_store_from_id,
                storeToId=self.test_store_to_id,
                items=[
                    InternalTransferItemDto(
                        product_id=self.test_good_id,
                        amount=5.0
                    )
                ]
            )
            
            internal_transfer_result = await self.api.v2_documents_internal_transfer_post(
                internal_transfer_dto=internal_transfer_document
            )
            self.assertIsNotNone(internal_transfer_result)
            self.assertEqual(internal_transfer_result.result, RequestResultDtoEnum.SUCCESS)
            
        except Exception as e:
            self.fail(f"V2 documents internal transfer POST failed with error: {str(e)}")

    async def test_v2_documents_internal_transfer_by_number_get(self) -> None:
        """Test case for v2_documents_internal_transfer_by_number_get
        
        Получение документа внутреннего перемещения по номеру
        """
        try:
            internal_transfer_result = await self.api.v2_documents_internal_transfer_by_number_get(
                document_number="0001"
            )
            self.assertGreater(len(internal_transfer_result), 0)
        except Exception as e:
            self.fail(f"V2 documents internal transfer by number GET failed with error: {str(e)}")

    async def test_v2_documents_internal_transfer_by_id_get(self) -> None:
        """Test case for v2_documents_internal_transfer_by_id_get
        
        Получение документа внутреннего перемещения по ID
        """
        try:
            internal_transfer_result = await self.api.v2_documents_internal_transfer_by_id_get(
                id="91b2645a-2f97-1543-0197-a99407436cd6"
            )
            self.assertIsNotNone(internal_transfer_result)
        except Exception as e:
            self.fail(f"V2 documents internal transfer by id GET failed with error: {str(e)}")

if __name__ == '__main__':
    unittest.main()
