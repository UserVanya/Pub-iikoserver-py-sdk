# coding: utf-8

"""
    iikoServer API

    API Server позволяет сделать интеграции, которые предназначены для работы с номенклатурой, отчетами, документами, данными сотрудников и приказами.   ### Ограничения и рекомендации - Запросы должны выполняться последовательно друг за другом - Запрашивайте данные за период не длиннее одного месяца, в идеале — за один день или неделю - Для OLAPv2-отчетов рекомендуется устанавливать build-summary=false - При построении OLAPv2-отчета рекомендуется использовать не более 7 полей - Перед выполнением запросов проверяйте их на демо сервере

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from datetime import datetime
import unittest
import os
import hashlib
import asyncio
import json
from datetime import timedelta

from iikoserver_client.api.reference_data_api import ReferenceDataApi
from iikoserver_client.api.session_management_api import SessionManagementApi
from iikoserver_client import ApiClient
from iikoserver_client.configuration import Configuration
from iikoserver_client.api.invoices_management_api import InvoicesManagementApi
from iikoserver_client.api.corporation_management_api import CorporationManagementApi
from iikoserver_client.api.nomenclature_management_api import NomenclatureManagementApi
from iikoserver_client.api.supplers_management_api import SupplersManagementApi
from iikoserver_client.models.incoming_invoice_item_xml import IncomingInvoiceItemXml
from iikoserver_client.models.incoming_invoice_xml import IncomingInvoiceXml
from iikoserver_client.models.incoming_invoice_xml_items import IncomingInvoiceXmlItems
from iikoserver_client.models.outgoing_invoice_item_xml import OutgoingInvoiceItemXml
from iikoserver_client.models.outgoing_invoice_xml import OutgoingInvoiceXml
from iikoserver_client.models.outgoing_invoice_xml_items import OutgoingInvoiceXmlItems
from iikoserver_client.models.returned_invoice_xml import ReturnedInvoiceXml
from iikoserver_client.models.returned_invoice_item_xml import ReturnedInvoiceItemXml
from iikoserver_client.models.returned_invoice_xml_items import ReturnedInvoiceXmlItems
from iikoserver_client.models.root_type_enum import RootTypeEnum
from iikoserver_client.models.document_status_enum import DocumentStatusEnum

class TestInvoicesManagementApi(unittest.IsolatedAsyncioTestCase):
    """InvoicesManagementApi unit test stubs"""

    async def asyncSetUp(self) -> None:
        # Read credentials from env variables or set them directly
        self.server_url = os.environ.get("IIKO_SERVER_URL", None)
        self.login = os.environ.get("IIKO_SERVER_LOGIN", None)  # Replace with your login
        self.password = os.environ.get("IIKO_SERVER_PASSWORD", None)  # Replace with your password
        self.password_hash = hashlib.sha1(self.password.encode()).hexdigest()
        
        # Create configuration
        self.config = Configuration(host=self.server_url, debug=True)
        
        # Create API client with context manager support
        self.client = ApiClient(configuration=self.config)
        self.test_good_id = "244079d3-3fa1-4479-96ef-e8183ed96de9"
        self.test_supplier_id = "5674ec93-12df-4314-ae10-21fa102d4cdc"
        self.test_store_id = "1239d270-1bbe-f64f-b7ea-5f00518ef508"
        self.session_api = SessionManagementApi(api_client=self.client)
        self.corporates_api = CorporationManagementApi(api_client=self.client)
        self.nomenclature_api = NomenclatureManagementApi(api_client=self.client)
        self.suppliers_api = SupplersManagementApi(api_client=self.client)
        self.reference_api = ReferenceDataApi(api_client=self.client)
        await self.session_api.auth_post(login=self.login, var_pass=self.password_hash)
        self.api = InvoicesManagementApi(api_client=self.client)

    async def asyncTearDown(self) -> None:
        # Make sure to properly close all connections
        try:
            await self.session_api.logout_post()
        except Exception as e:
            print(f"Warning: logout failed: {e}")
        
        # Ensure client is closed properly
        await self.client.close()
        
        # Give event loop time to cleanup resources
        await asyncio.sleep(0.1)

    async def test_documents_import_incoming_invoice_post(self) -> None:
        """Test case for documents_import_incoming_invoice_post

        Загрузка и редактирование приходной накладной
        """
        try:
            nomenclature_response = await self.nomenclature_api.v2_entities_products_list_get(ids=[self.test_good_id])
            dishware_item = next((dish for dish in nomenclature_response if dish.name == "Шампанка"), None)
            
            incoming_invoice_xml = IncomingInvoiceXml(
                    items=IncomingInvoiceXmlItems(
                        item=[
                            IncomingInvoiceItemXml(
                                isAdditionalExpense=False,
                                amount=2,
                                product=dishware_item.id,
                                num=1,
                                amountUnit=dishware_item.main_unit,
                                sum=100,
                                price=50,
                                store=self.test_store_id,
                                discountSum=0,
                                vatPercent=0,
                                actualPrice=2,
                            ),
                        ]
                    ),
                    invoice="t1",
                    defaultStore=self.test_store_id,
                    comment="Тестовая приходная накладная",
                    dateIncoming=datetime.now().strftime("%d.%m.%Y"),
                    supplier=self.test_supplier_id,
                )
            print(json.dumps(incoming_invoice_xml.to_dict(), indent=4, ensure_ascii=False))
            
            doc_val_result = await self.api.documents_import_incoming_invoice_post(
                incoming_invoice_xml=incoming_invoice_xml
            )
            print(doc_val_result)
        except Exception as e:
            self.fail(f"Documents import incoming invoice POST failed with error: {str(e)}")

    async def test_documents_import_outgoing_invoice_post(self) -> None:
        """Test case for documents_import_outgoing_invoice_post

        Загрузка и редактирование расходной накладной
        """    
        try:
            nomenclature_response = await self.nomenclature_api.v2_entities_products_list_get(ids=[self.test_good_id])
            dishware_item = next((dish for dish in nomenclature_response if dish.name == "Шампанка"), None)
            
            outgoing_invoice_xml = OutgoingInvoiceXml(
                items=OutgoingInvoiceXmlItems(
                    item=[
                    OutgoingInvoiceItemXml(
                        productId=dishware_item.id,
                        amount=2,
                        price=50,
                        sum=100
                    ),
                    OutgoingInvoiceItemXml(
                        productId=dishware_item.id,
                        amount=3,
                        price=30,
                        sum=90
                    ),
                ]),
                comment="Тестовая расходная накладная",
                dateIncoming=datetime.today().date(),
                useDefaultDocumentTime=False,
                defaultStoreId=self.test_store_id
            )
            print(outgoing_invoice_xml.model_dump_json(indent=4))
            doc_val_result = await self.api.documents_import_outgoing_invoice_post(
                outgoing_invoice_xml=outgoing_invoice_xml,
            )
            print(doc_val_result)
        except Exception as e:
            self.fail(f"Documents import outgoing invoice POST failed with error: {str(e)}")

    async def test_documents_export_incoming_invoice_get(self) -> None:
        """Test case for documents_export_incoming_invoice_get

        Получение приходной накладной
        """
        try:
            incoming_invoices = await self.api.documents_export_incoming_invoice_get(
                var_from=datetime.today().date(),
                to=datetime.today().date(),
                revision_from=-1,
            )
            print(incoming_invoices.model_dump_json(indent=4))
        except Exception as e:
            self.fail(f"Documents export incoming invoice GET failed with error: {str(e)}")

    async def test_documents_export_outgoing_invoice_get(self) -> None:
        """Test case for documents_export_outgoing_invoice_get

        Получение расходной накладной
        """
        try:
            outgoing_invoices = await self.api.documents_export_outgoing_invoice_get(
                var_from=datetime.today().date(),
                to=datetime.today().date()
            )
            print(outgoing_invoices.model_dump_json(indent=4))
        except Exception as e:
            self.fail(f"Documents export outgoing invoice GET failed with error: {str(e)}")
    
    async def test_documents_export_incoming_invoice_by_number_get(self) -> None:
        """Test case for documents_export_incoming_invoice_by_number_get
        
        Получение приходной накладной по номеру
        """
        try:
            invoices_response = await self.api.documents_export_incoming_invoice_get(
                var_from=datetime.today().date(),
                to=datetime.today().date()
            )
            incoming_invoices = invoices_response.documents
            self.assertGreater(len(incoming_invoices), 0)
            invoice_by_number_response = await self.api.documents_export_incoming_invoice_by_number_get(
                number=incoming_invoices[0].document_number,
                current_year=True
            )
            print(invoice_by_number_response.model_dump_json(indent=4))
            self.assertGreater(len(invoice_by_number_response.documents), 0)
        except Exception as e:
            self.fail(f"Documents export incoming invoice by number GET failed with error: {str(e)}")

    async def test_documents_export_outgoing_invoice_by_number_get(self) -> None:
        """Test case for documents_export_outgoing_invoice_by_number_get
        
        Получение расходной накладной по номеру
        """
        try:
            invoices_response = await self.api.documents_export_outgoing_invoice_get(
                var_from=datetime.today().date(),
                to=datetime.today().date()
            )
            outgoing_invoices = invoices_response.documents
            self.assertGreater(len(outgoing_invoices), 0)
            invoice_by_number_response = await self.api.documents_export_outgoing_invoice_by_number_get(
                number=outgoing_invoices[0].document_number,
                current_year=True
            )
            print(invoice_by_number_response.model_dump_json(indent=4))
            self.assertGreater(len(invoice_by_number_response.documents), 0)
        except Exception as e:
            self.fail(f"Documents export outgoing invoice by number GET failed with error: {str(e)}")

    async def test_documents_unprocess_outgoing_invoice_post(self) -> None:
        """Test case for documents_unprocess_outgoing_invoice_post

        Получение непроведенных приходных накладных
        """
        try:

            outgoing_invoices = await self.api.documents_export_outgoing_invoice_get(
                var_from=datetime.today().date(),
                to=datetime.today().date()
            )
            invoices = [invoice for invoice in outgoing_invoices.documents if invoice.status == DocumentStatusEnum.PROCESSED]
            self.assertEqual(len(invoices) > 0, True)
            unprocess_result = await self.api.documents_unprocess_outgoing_invoice_post(
                outgoing_invoice_xml=invoices[0]
            )
            self.assertEqual(unprocess_result.valid, True)
        except Exception as e:
            self.fail(f"Documents unprocess outgoing invoice POST failed with error: {str(e)}")

    async def test_documents_unprocess_incoming_invoice_post(self) -> None:
        """Test case for documents_unprocess_incoming_invoice_post

        Получение непроведенных расходных накладных
        """
        try:
            incoming_invoices = await self.api.documents_export_incoming_invoice_get(
                var_from=datetime.today().date(),
                to=datetime.today().date()
            )
            invoices = [invoice for invoice in incoming_invoices.documents if invoice.status == DocumentStatusEnum.PROCESSED]
            self.assertEqual(len(invoices) > 0, True)
            #print()
            unprocess_result = await self.api.documents_unprocess_incoming_invoice_post(
                incoming_invoice_xml=invoices[0]
            )
            self.assertEqual(unprocess_result.valid, True)
        except Exception as e:
            self.fail(f"Documents unprocess incoming invoice POST failed with error: {str(e)}")

    async def test_documents_import_returned_invoice_post(self) -> None:
        """Test case for documents_import_returned_invoice_post

        Загрузка и редактирование возвратной накладной
        """
        try:
            incoming_invoices_response = await self.api.documents_export_incoming_invoice_get(
                var_from=datetime.today().date(),
                to=datetime.today().date()
            )
            incoming_invoices = [doc for doc in incoming_invoices_response.documents if doc.status == DocumentStatusEnum.PROCESSED]
            self.assertGreater(len(incoming_invoices), 0)
            
            date_incoming = (datetime.strptime(incoming_invoices[0].date_incoming, "%Y-%m-%dT%H:%M:%S"))
            date_returned = date_incoming + timedelta(days=1)
            returned_invoice_xml = ReturnedInvoiceXml( 
                incomingInvoiceNumber=incoming_invoices[0].document_number,
                incomingInvoiceDate=date_incoming.strftime("%Y-%m-%dT%H:%M:%S"),
                comment="Тестовая возвратная накладная",
                dateIncoming=date_returned.strftime("%Y-%m-%dT%H:%M:%S"),
                useDefaultDocumentTime=False,
                defaultStoreId=incoming_invoices[0].default_store,
                counteragentId=incoming_invoices[0].supplier,
                items=ReturnedInvoiceXmlItems(
                    item=[
                        ReturnedInvoiceItemXml(
                            productId=incoming_invoices[0].items.item[0].product,
                            amount=incoming_invoices[0].items.item[0].amount-1,
                            price=incoming_invoices[0].items.item[0].price,
                            sum=incoming_invoices[0].items.item[0].sum
                        )
                    ]
                )
            )
            import_returned_invoice_result = await self.api.documents_import_returned_invoice_post(
                returned_invoice_xml=returned_invoice_xml
            )
            print(import_returned_invoice_result.model_dump_json(indent=4))
            self.assertEqual(import_returned_invoice_result.valid, True)
        except Exception as e:
            self.fail(f"Documents import returned invoice POST failed with error: {str(e)}")
        
if __name__ == '__main__':
    unittest.main()
