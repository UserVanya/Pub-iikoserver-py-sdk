# coding: utf-8

"""
    iikoServer API

    API Server позволяет сделать интеграции, которые предназначены для работы с номенклатурой, отчетами, документами, данными сотрудников и приказами.   ### Ограничения и рекомендации - Запросы должны выполняться последовательно друг за другом - Запрашивайте данные за период не длиннее одного месяца, в идеале — за один день или неделю - Для OLAPv2-отчетов рекомендуется устанавливать build-summary=false - При построении OLAPv2-отчета рекомендуется использовать не более 7 полей - Перед выполнением запросов проверяйте их на демо сервере

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set, Union
from typing_extensions import Self

# XML support imports
from lxml import etree
from lxml.etree import Element, SubElement

class PayOutSettingsDto(BaseModel):
    """
    PayOutSettingsDto
    """ # noqa: E501
    pay_out_type_id: StrictStr = Field(description="UUID типа изъятия в базе iiko", alias="payOutTypeId")
    pay_out_date: date = Field(description="Дата в формате yyyy-MM-dd. Время проставляется текущее", alias="payOutDate")
    counteragent: Optional[StrictStr] = Field(default=None, description="UUID контрагента в базе iiko. В зависимости от типа изъятия")
    department_sum_map: Dict[str, Union[StrictFloat, StrictInt]] = Field(description="Торговое предприятие -> сумма изъятия", alias="departmentSumMap")
    payroll_id: Optional[StrictStr] = Field(default=None, description="UUID платежной ведомости в базе iiko. Указывается если изъятие происходит на счет 'Текущие расчеты с сотрудниками'", alias="payrollId")
    comment: Optional[StrictStr] = Field(default=None, description="Комментарий")
    __properties: ClassVar[List[str]] = ["payOutTypeId", "payOutDate", "counteragent", "departmentSumMap", "payrollId", "comment"]
    
    # XML metadata for the class
    __xml_config: ClassVar[Dict[str, Any]] = {
        "root_name": "PayOutSettingsDto",
        
        
        "field_configs": {
            "pay_out_type_id": {
                "xml_name": "payOutTypeId",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "pay_out_date": {
                "xml_name": "payOutDate",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "counteragent": {
                "xml_name": "counteragent",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "department_sum_map": {
                "xml_name": "departmentSumMap",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "payroll_id": {
                "xml_name": "payrollId",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "comment": {
                "xml_name": "comment",
                
                
                "is_attribute": False,
                "is_wrapped": False
            }
        }
    }


    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PayOutSettingsDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if counteragent (nullable) is None
        # and model_fields_set contains the field
        if self.counteragent is None and "counteragent" in self.model_fields_set:
            _dict['counteragent'] = None

        # set to None if payroll_id (nullable) is None
        # and model_fields_set contains the field
        if self.payroll_id is None and "payroll_id" in self.model_fields_set:
            _dict['payrollId'] = None

        # set to None if comment (nullable) is None
        # and model_fields_set contains the field
        if self.comment is None and "comment" in self.model_fields_set:
            _dict['comment'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PayOutSettingsDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "payOutTypeId": obj.get("payOutTypeId"),
            "payOutDate": obj.get("payOutDate"),
            "counteragent": obj.get("counteragent"),
            "departmentSumMap": obj.get("departmentSumMap"),
            "payrollId": obj.get("payrollId"),
            "comment": obj.get("comment")
        })
        return _obj



    @classmethod
    def from_xml(cls, xml_str: str) -> Optional[Self]:
        """Create an instance of PayOutSettingsDto from an XML string"""
        try:
            if isinstance(xml_str, str):
                xml_str = xml_str.encode('utf-8')
            root = etree.fromstring(xml_str)
            return cls.from_xml_element(root)
        except Exception as e:
            raise ValueError(f"Failed to parse XML: {e}")

    @classmethod
    def from_xml_element(cls, element: Element) -> Optional[Self]:
        """Create an instance of PayOutSettingsDto from an XML element"""
        return cls._from_xml_element_internal(element)

    @classmethod
    def _from_xml_element_internal(cls, element: Element) -> Optional[Self]:
        """Internal method to create instance from XML element"""
        if element is None:
            return None

        data = {}
        
        # Process field: pay_out_type_id (XML name: payOutTypeId)
        # Handle XML element: pay_out_type_id
        # Single element field: pay_out_type_id
        child_element = element.find("payOutTypeId")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                data["payOutTypeId"] = text_value
                
        
        # Process field: pay_out_date (XML name: payOutDate)
        # Handle XML element: pay_out_date
        # Single element field: pay_out_date
        child_element = element.find("payOutDate")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                
                # Handle other primitive types (date, datetime, uuid, etc.)
                # Date field - handle "null" specially
                if text_value == "null":
                    data["payOutDate"] = None
                else:
                    data["payOutDate"] = text_value
                
                
        
        # Process field: counteragent (XML name: counteragent)
        # Handle XML element: counteragent
        # Single element field: counteragent
        child_element = element.find("counteragent")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                data["counteragent"] = text_value
                
        
        # Process field: department_sum_map (XML name: departmentSumMap)
        # Handle XML element: department_sum_map
        # Map field: department_sum_map (not commonly used in XML)
        # This is a simplified implementation
        child_elements = element.findall("departmentSumMap")
        map_data = {}
        for child in child_elements:
            key = child.get('key') or child.tag
            text_value = child.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                map_data[key] = text_value
        data["departmentSumMap"] = map_data
        
        # Process field: payroll_id (XML name: payrollId)
        # Handle XML element: payroll_id
        # Single element field: payroll_id
        child_element = element.find("payrollId")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                data["payrollId"] = text_value
                
        
        # Process field: comment (XML name: comment)
        # Handle XML element: comment
        # Single element field: comment
        child_element = element.find("comment")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                data["comment"] = text_value
                
        
        
        return cls.from_dict(data)

    def to_xml(self) -> str:
        """Create an XML string representation of the model"""
        root_element = Element(self.__xml_config.get("root_name", self.__class__.__name__))
        
        # Populate the XML element with model data
        self._to_xml_element_internal(root_element)
        
        # Convert to string with XML declaration
        return etree.tostring(root_element, encoding="utf-8", pretty_print=True, xml_declaration=True).decode("utf-8")

    def _to_xml_element_internal(self, element: Element) -> None:
        """Internal method to populate an XML element with model data"""
        
        # Process field: pay_out_type_id (XML name: payOutTypeId)
        value = getattr(self, "pay_out_type_id", None)
        if value is not None:  # Skip None values
            # Single element field: pay_out_type_id
            child_element = SubElement(element, "payOutTypeId")
            child_element.text = value
            
        # Process field: pay_out_date (XML name: payOutDate)
        value = getattr(self, "pay_out_date", None)
        if value is not None:  # Skip None values
            # Single element field: pay_out_date
            child_element = SubElement(element, "payOutDate")
            
            # Handle other primitive types (date, datetime, uuid, etc.)
            child_element.text = str(value)
            
        # Process field: counteragent (XML name: counteragent)
        value = getattr(self, "counteragent", None)
        if value is not None:  # Skip None values
            # Single element field: counteragent
            child_element = SubElement(element, "counteragent")
            child_element.text = value
            
        # Process field: department_sum_map (XML name: departmentSumMap)
        value = getattr(self, "department_sum_map", None)
        if value is not None:  # Skip None values
            # Map field: department_sum_map (not commonly used in XML)
            # This is a simplified implementation
            for key, item in value.items():
                map_element = SubElement(element, "departmentSumMap")
                map_element.set("key", key)
                map_element.text = str(item)
        # Process field: payroll_id (XML name: payrollId)
        value = getattr(self, "payroll_id", None)
        if value is not None:  # Skip None values
            # Single element field: payroll_id
            child_element = SubElement(element, "payrollId")
            child_element.text = value
            
        # Process field: comment (XML name: comment)
        value = getattr(self, "comment", None)
        if value is not None:  # Skip None values
            # Single element field: comment
            child_element = SubElement(element, "comment")
            child_element.text = value
            


