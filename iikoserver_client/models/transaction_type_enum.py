# coding: utf-8

"""
    iikoServer API

    API Server позволяет сделать интеграции, которые предназначены для работы с номенклатурой, отчетами, документами, данными сотрудников и приказами.   ### Ограничения и рекомендации - Запросы должны выполняться последовательно друг за другом - Запрашивайте данные за период не длиннее одного месяца, в идеале — за один день или неделю - Для OLAPv2-отчетов рекомендуется устанавливать build-summary=false - При построении OLAPv2-отчета рекомендуется использовать не более 7 полей - Перед выполнением запросов проверяйте их на демо сервере

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import json
from enum import Enum
from typing import Optional
from typing_extensions import Self

# XML support imports
from lxml import etree
from lxml.etree import Element


class TransactionTypeEnum(str, Enum):
    """
    Типы транзакций в системе
    """

    """
    allowed enum values
    """
    OPENING_BALANCE = 'OPENING_BALANCE'
    CUSTOM = 'CUSTOM'
    CASH = 'CASH'
    PREPAY_CLOSED = 'PREPAY_CLOSED'
    PREPAY = 'PREPAY'
    PREPAY_RETURN = 'PREPAY_RETURN'
    PREPAY_CLOSED_RETURN = 'PREPAY_CLOSED_RETURN'
    DISCOUNT = 'DISCOUNT'
    CARD = 'CARD'
    CREDIT = 'CREDIT'
    PAYIN = 'PAYIN'
    PAYOUT = 'PAYOUT'
    PAY_COLLECTION = 'PAY_COLLECTION'
    CASH_CORRECTION = 'CASH_CORRECTION'
    INVENTORY_CORRECTION = 'INVENTORY_CORRECTION'
    STORE_COST_CORRECTION = 'STORE_COST_CORRECTION'
    CASH_SURPLUS = 'CASH_SURPLUS'
    CASH_SHORTAGE = 'CASH_SHORTAGE'
    PENALTY = 'PENALTY'
    BONUS = 'BONUS'
    INVOICE = 'INVOICE'
    NDS_INCOMING = 'NDS_INCOMING'
    NDS_SALES = 'NDS_SALES'
    SALES_REVENUE = 'SALES_REVENUE'
    OUTGOING_INVOICE = 'OUTGOING_INVOICE'
    OUTGOING_INVOICE_REVENUE = 'OUTGOING_INVOICE_REVENUE'
    RETURNED_INVOICE = 'RETURNED_INVOICE'
    RETURNED_INVOICE_REVENUE = 'RETURNED_INVOICE_REVENUE'
    WRITEOFF = 'WRITEOFF'
    SESSION_WRITEOFF = 'SESSION_WRITEOFF'
    TRANSFER = 'TRANSFER'
    TRANSFORMATION = 'TRANSFORMATION'
    TARIFF_HOUR = 'TARIFF_HOUR'
    ON_THE_HOUSE = 'ON_THE_HOUSE'
    ADVANCE = 'ADVANCE'
    INCOMING_SERVICE = 'INCOMING_SERVICE'
    OUTGOING_SERVICE = 'OUTGOING_SERVICE'
    INCOMING_SERVICE_PAYMENT = 'INCOMING_SERVICE_PAYMENT'
    OUTGOING_SERVICE_PAYMENT = 'OUTGOING_SERVICE_PAYMENT'
    CLOSE_AT_EMPLOYEE_EXPENSE = 'CLOSE_AT_EMPLOYEE_EXPENSE'
    INCENTIVE_PAYMENT = 'INCENTIVE_PAYMENT'
    TARIFF_PERCENT = 'TARIFF_PERCENT'
    SESSION_ACCEPTANCE = 'SESSION_ACCEPTANCE'
    EMPLOYEE_CASH_PAYMENT = 'EMPLOYEE_CASH_PAYMENT'
    EMPLOYEE_PAYMENT = 'EMPLOYEE_PAYMENT'
    INVOICE_PAYMENT = 'INVOICE_PAYMENT'
    OUTGOING_DOCUMENT_PAYMENT = 'OUTGOING_DOCUMENT_PAYMENT'
    OUTGOING_SALES_DOCUMENT_PAYMENT = 'OUTGOING_SALES_DOCUMENT_PAYMENT'
    PRODUCTION = 'PRODUCTION'
    SALES_RETURN_PAYMENT = 'SALES_RETURN_PAYMENT'
    SALES_RETURN_WRITEOFF = 'SALES_RETURN_WRITEOFF'
    DISASSEMBLE = 'DISASSEMBLE'

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of TransactionTypeEnum from a JSON string"""
        return cls(json.loads(json_str))

    @classmethod
    def from_xml(cls, xml_str: str) -> Optional[Self]:
        """Create an instance of TransactionTypeEnum from an XML string"""
        try:
            if isinstance(xml_str, str):
                xml_str = xml_str.encode('utf-8')
            root = etree.fromstring(xml_str)
            return cls.from_xml_element(root)
        except Exception as e:
            raise ValueError(f"Failed to parse XML: {e}")

    @classmethod
    def from_xml_element(cls, element: Element) -> Optional[Self]:
        """Create an instance of TransactionTypeEnum from an XML element"""
        if element is None:
            return None
        
        # Get the text content of the element
        text_value = element.text
        if text_value is not None and text_value.strip() != "" and text_value != "null":
            try:
                return cls(text_value)
            except ValueError:
                # If the value doesn't match any enum value, return None or raise error
                # depending on desired behavior
                return None
        return None


