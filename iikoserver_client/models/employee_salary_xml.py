# coding: utf-8

"""
    iikoServer API

    API Server позволяет сделать интеграции, которые предназначены для работы с номенклатурой, отчетами, документами, данными сотрудников и приказами.   ### Ограничения и рекомендации - Запросы должны выполняться последовательно друг за другом - Запрашивайте данные за период не длиннее одного месяца, в идеале — за один день или неделю - Для OLAPv2-отчетов рекомендуется устанавливать build-summary=false - При построении OLAPv2-отчета рекомендуется использовать не более 7 полей - Перед выполнением запросов проверяйте их на демо сервере

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set, Union
from typing_extensions import Self

# XML support imports
from lxml import etree
from lxml.etree import Element, SubElement

class EmployeeSalaryXml(BaseModel):
    """
    EmployeeSalaryXml
    """ # noqa: E501
    date_from: Optional[datetime] = Field(default=None, description="Дата начала действия оклада", alias="dateFrom")
    date_to: Optional[datetime] = Field(default=None, description="Дата окончания действия оклада", alias="dateTo")
    employee_id: Optional[StrictStr] = Field(default=None, description="Идентификатор сотрудника", alias="employeeId")
    payment: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Сумма оклада")
    __properties: ClassVar[List[str]] = ["dateFrom", "dateTo", "employeeId", "payment"]
    
    # XML metadata for the class
    __xml_config: ClassVar[Dict[str, Any]] = {
        "root_name": "salary",
        
        
        "field_configs": {
            "date_from": {
                "xml_name": "dateFrom",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "date_to": {
                "xml_name": "dateTo",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "employee_id": {
                "xml_name": "employeeId",
                
                
                "is_attribute": False,
                "is_wrapped": False
            },
            "payment": {
                "xml_name": "payment",
                
                
                "is_attribute": False,
                "is_wrapped": False
            }
        }
    }


    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EmployeeSalaryXml from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if date_from (nullable) is None
        # and model_fields_set contains the field
        if self.date_from is None and "date_from" in self.model_fields_set:
            _dict['dateFrom'] = None

        # set to None if date_to (nullable) is None
        # and model_fields_set contains the field
        if self.date_to is None and "date_to" in self.model_fields_set:
            _dict['dateTo'] = None

        # set to None if employee_id (nullable) is None
        # and model_fields_set contains the field
        if self.employee_id is None and "employee_id" in self.model_fields_set:
            _dict['employeeId'] = None

        # set to None if payment (nullable) is None
        # and model_fields_set contains the field
        if self.payment is None and "payment" in self.model_fields_set:
            _dict['payment'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EmployeeSalaryXml from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "dateFrom": obj.get("dateFrom"),
            "dateTo": obj.get("dateTo"),
            "employeeId": obj.get("employeeId"),
            "payment": obj.get("payment")
        })
        return _obj



    @classmethod
    def from_xml(cls, xml_str: str) -> Optional[Self]:
        """Create an instance of EmployeeSalaryXml from an XML string"""
        try:
            if isinstance(xml_str, str):
                xml_str = xml_str.encode('utf-8')
            root = etree.fromstring(xml_str)
            return cls.from_xml_element(root)
        except Exception as e:
            raise ValueError(f"Failed to parse XML: {e}")

    @classmethod
    def from_xml_element(cls, element: Element) -> Optional[Self]:
        """Create an instance of EmployeeSalaryXml from an XML element"""
        return cls._from_xml_element_internal(element)

    @classmethod
    def _from_xml_element_internal(cls, element: Element) -> Optional[Self]:
        """Internal method to create instance from XML element"""
        if element is None:
            return None

        data = {}
        
        # Process field: date_from (XML name: dateFrom)
        # Handle XML element: date_from
        # Single element field: date_from
        child_element = element.find("dateFrom")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                
                # Handle other primitive types (date, datetime, uuid, etc.)
                # DateTime field - handle "null" specially  
                if text_value == "null":
                    data["dateFrom"] = None
                else:
                    data["dateFrom"] = text_value
                
                
        
        # Process field: date_to (XML name: dateTo)
        # Handle XML element: date_to
        # Single element field: date_to
        child_element = element.find("dateTo")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                
                # Handle other primitive types (date, datetime, uuid, etc.)
                # DateTime field - handle "null" specially  
                if text_value == "null":
                    data["dateTo"] = None
                else:
                    data["dateTo"] = text_value
                
                
        
        # Process field: employee_id (XML name: employeeId)
        # Handle XML element: employee_id
        # Single element field: employee_id
        child_element = element.find("employeeId")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                data["employeeId"] = text_value
                
        
        # Process field: payment (XML name: payment)
        # Handle XML element: payment
        # Single element field: payment
        child_element = element.find("payment")
        if child_element is not None:
            # Check for null or empty values
            text_value = child_element.text
            if text_value is not None and text_value.strip() != "" and text_value != "null":
                try:
                    data["payment"] = float(text_value)
                except ValueError:
                    data["payment"] = text_value
                
        
        
        return cls.from_dict(data)

    def to_xml(self) -> str:
        """Create an XML string representation of the model"""
        root_element = Element(self.__xml_config.get("root_name", self.__class__.__name__))
        
        # Populate the XML element with model data
        self._to_xml_element_internal(root_element)
        
        # Convert to string with XML declaration
        return etree.tostring(root_element, encoding="utf-8", pretty_print=True, xml_declaration=True).decode("utf-8")

    def _to_xml_element_internal(self, element: Element) -> None:
        """Internal method to populate an XML element with model data"""
        
        # Process field: date_from (XML name: dateFrom)
        value = getattr(self, "date_from", None)
        if value is not None:  # Skip None values
            # Single element field: date_from
            child_element = SubElement(element, "dateFrom")
            
            # Handle other primitive types (date, datetime, uuid, etc.)
            child_element.text = str(value)
            
        # Process field: date_to (XML name: dateTo)
        value = getattr(self, "date_to", None)
        if value is not None:  # Skip None values
            # Single element field: date_to
            child_element = SubElement(element, "dateTo")
            
            # Handle other primitive types (date, datetime, uuid, etc.)
            child_element.text = str(value)
            
        # Process field: employee_id (XML name: employeeId)
        value = getattr(self, "employee_id", None)
        if value is not None:  # Skip None values
            # Single element field: employee_id
            child_element = SubElement(element, "employeeId")
            child_element.text = value
            
        # Process field: payment (XML name: payment)
        value = getattr(self, "payment", None)
        if value is not None:  # Skip None values
            # Single element field: payment
            child_element = SubElement(element, "payment")
            child_element.text = str(value)
            


