# coding: utf-8

"""
    iikoServer API

    API Server позволяет сделать интеграции, которые предназначены для работы с номенклатурой, отчетами, документами, данными сотрудников и приказами.   ### Ограничения и рекомендации - Запросы должны выполняться последовательно друг за другом - Запрашивайте данные за период не длиннее одного месяца, в идеале — за один день или неделю - Для OLAPv2-отчетов рекомендуется устанавливать build-summary=false - При построении OLAPv2-отчета рекомендуется использовать не более 7 полей - Перед выполнением запросов проверяйте их на демо сервере

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date, datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import List, Optional, Union
from typing_extensions import Annotated
from iikoserver_client.models.attendance_types_xml import AttendanceTypesXml
from iikoserver_client.models.attendance_xml import AttendanceXml
from iikoserver_client.models.attendances_xml import AttendancesXml
from iikoserver_client.models.availabilities_xml import AvailabilitiesXml
from iikoserver_client.models.employee_roles_xml import EmployeeRolesXml
from iikoserver_client.models.employee_salaries_xml import EmployeeSalariesXml
from iikoserver_client.models.employee_salary_xml import EmployeeSalaryXml
from iikoserver_client.models.employee_xml import EmployeeXml
from iikoserver_client.models.employees_xml import EmployeesXml
from iikoserver_client.models.schedule_types_xml import ScheduleTypesXml
from iikoserver_client.models.schedule_xml import ScheduleXml
from iikoserver_client.models.schedules_xml import SchedulesXml

from iikoserver_client.api_client import ApiClient, RequestSerialized
from iikoserver_client.api_response import ApiResponse
from iikoserver_client.rest import RESTResponseType


class EmployeesManagementApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def employees_attendance_by_department_department_code_by_employee_employee_uuid_get(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendancesXml:
        """Получить явки сотрудника в подразделении

        Возвращает все явки указанного сотрудника в указанном подразделении, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_department_department_code_by_employee_employee_uuid_get_serialize(
            department_code=department_code,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_by_department_department_code_by_employee_employee_uuid_get_with_http_info(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendancesXml]:
        """Получить явки сотрудника в подразделении

        Возвращает все явки указанного сотрудника в указанном подразделении, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_department_department_code_by_employee_employee_uuid_get_serialize(
            department_code=department_code,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_by_department_department_code_by_employee_employee_uuid_get_without_preload_content(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить явки сотрудника в подразделении

        Возвращает все явки указанного сотрудника в указанном подразделении, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_department_department_code_by_employee_employee_uuid_get_serialize(
            department_code=department_code,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_by_department_department_code_by_employee_employee_uuid_get_serialize(
        self,
        department_code,
        employee_uuid,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_code is not None:
            _path_params['departmentCode'] = department_code
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/attendance/byDepartment/{departmentCode}/byEmployee/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_by_department_department_code_get(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendancesXml:
        """Получить явки по подразделению

        Возвращает все явки указанного подразделения, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_department_department_code_get_serialize(
            department_code=department_code,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_by_department_department_code_get_with_http_info(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendancesXml]:
        """Получить явки по подразделению

        Возвращает все явки указанного подразделения, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_department_department_code_get_serialize(
            department_code=department_code,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_by_department_department_code_get_without_preload_content(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить явки по подразделению

        Возвращает все явки указанного подразделения, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_department_department_code_get_serialize(
            department_code=department_code,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_by_department_department_code_get_serialize(
        self,
        department_code,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_code is not None:
            _path_params['departmentCode'] = department_code
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/attendance/byDepartment/{departmentCode}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_by_employee_employee_uuid_get(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendancesXml:
        """Получить явки сотрудника

        Возвращает все явки указанного сотрудника, пересекающие интервал отчета

        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_employee_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_by_employee_employee_uuid_get_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendancesXml]:
        """Получить явки сотрудника

        Возвращает все явки указанного сотрудника, пересекающие интервал отчета

        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_employee_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_by_employee_employee_uuid_get_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить явки сотрудника

        Возвращает все явки указанного сотрудника, пересекающие интервал отчета

        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_employee_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_by_employee_employee_uuid_get_serialize(
        self,
        employee_uuid,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/attendance/byEmployee/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_by_id_attendance_uuid_delete(
        self,
        attendance_uuid: Annotated[StrictStr, Field(description="Идентификатор явки")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendanceXml:
        """Удалить явку

        Удаление явки по идентификатору

        :param attendance_uuid: Идентификатор явки (required)
        :type attendance_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_id_attendance_uuid_delete_serialize(
            attendance_uuid=attendance_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_by_id_attendance_uuid_delete_with_http_info(
        self,
        attendance_uuid: Annotated[StrictStr, Field(description="Идентификатор явки")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendanceXml]:
        """Удалить явку

        Удаление явки по идентификатору

        :param attendance_uuid: Идентификатор явки (required)
        :type attendance_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_id_attendance_uuid_delete_serialize(
            attendance_uuid=attendance_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_by_id_attendance_uuid_delete_without_preload_content(
        self,
        attendance_uuid: Annotated[StrictStr, Field(description="Идентификатор явки")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Удалить явку

        Удаление явки по идентификатору

        :param attendance_uuid: Идентификатор явки (required)
        :type attendance_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_by_id_attendance_uuid_delete_serialize(
            attendance_uuid=attendance_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_by_id_attendance_uuid_delete_serialize(
        self,
        attendance_uuid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if attendance_uuid is not None:
            _path_params['attendanceUUID'] = attendance_uuid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/employees/attendance/byId/{attendanceUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_create_post(
        self,
        attendance_xml: AttendanceXml,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendanceXml:
        """Создать явку

        Создание новой явки. При создании поле id может быть не заполнено. Даты округляются с точностью до минуты. Запрещается создание пересекающихся явок.

        :param attendance_xml: (required)
        :type attendance_xml: AttendanceXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_create_post_serialize(
            attendance_xml=attendance_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_create_post_with_http_info(
        self,
        attendance_xml: AttendanceXml,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendanceXml]:
        """Создать явку

        Создание новой явки. При создании поле id может быть не заполнено. Даты округляются с точностью до минуты. Запрещается создание пересекающихся явок.

        :param attendance_xml: (required)
        :type attendance_xml: AttendanceXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_create_post_serialize(
            attendance_xml=attendance_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_create_post_without_preload_content(
        self,
        attendance_xml: AttendanceXml,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Создать явку

        Создание новой явки. При создании поле id может быть не заполнено. Даты округляются с точностью до минуты. Запрещается создание пересекающихся явок.

        :param attendance_xml: (required)
        :type attendance_xml: AttendanceXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_create_post_serialize(
            attendance_xml=attendance_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_create_post_serialize(
        self,
        attendance_xml,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if attendance_xml is not None:
            _body_params = attendance_xml


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/employees/attendance/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_department_department_id_by_employee_employee_uuid_get(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendancesXml:
        """Получить явки сотрудника в подразделении по ID

        Возвращает все явки указанного сотрудника в указанном подразделении по ID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_department_department_id_by_employee_employee_uuid_get_serialize(
            department_id=department_id,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_department_department_id_by_employee_employee_uuid_get_with_http_info(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendancesXml]:
        """Получить явки сотрудника в подразделении по ID

        Возвращает все явки указанного сотрудника в указанном подразделении по ID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_department_department_id_by_employee_employee_uuid_get_serialize(
            department_id=department_id,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_department_department_id_by_employee_employee_uuid_get_without_preload_content(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="ID сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить явки сотрудника в подразделении по ID

        Возвращает все явки указанного сотрудника в указанном подразделении по ID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param employee_uuid: ID сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_department_department_id_by_employee_employee_uuid_get_serialize(
            department_id=department_id,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_department_department_id_by_employee_employee_uuid_get_serialize(
        self,
        department_id,
        employee_uuid,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_id is not None:
            _path_params['departmentId'] = department_id
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/attendance/department/{departmentId}/byEmployee/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_department_department_id_get(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendancesXml:
        """Получить явки по ID подразделения

        Возвращает все явки указанного подразделения по ID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_department_department_id_get_serialize(
            department_id=department_id,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_department_department_id_get_with_http_info(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendancesXml]:
        """Получить явки по ID подразделения

        Возвращает все явки указанного подразделения по ID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_department_department_id_get_serialize(
            department_id=department_id,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_department_department_id_get_without_preload_content(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить явки по ID подразделения

        Возвращает все явки указанного подразделения по ID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_department_department_id_get_serialize(
            department_id=department_id,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_department_department_id_get_serialize(
        self,
        department_id,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_id is not None:
            _path_params['departmentId'] = department_id
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/attendance/department/{departmentId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_get(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendancesXml:
        """Получить явки

        Возвращает все явки, пересекающие интервал отчета

        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_get_serialize(
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_get_with_http_info(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendancesXml]:
        """Получить явки

        Возвращает все явки, пересекающие интервал отчета

        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_get_serialize(
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_get_without_preload_content(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить явки

        Возвращает все явки, пересекающие интервал отчета

        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Добавлять ли к явкам информацию об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_get_serialize(
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendancesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_get_serialize(
        self,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/attendance',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_types_get(
        self,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Включать ли удаленные элементы в результат")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendanceTypesXml:
        """Получить типы явок

        Возвращает все не удаленные типы явок

        :param include_deleted: Включать ли удаленные элементы в результат
        :type include_deleted: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_types_get_serialize(
            include_deleted=include_deleted,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceTypesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_types_get_with_http_info(
        self,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Включать ли удаленные элементы в результат")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendanceTypesXml]:
        """Получить типы явок

        Возвращает все не удаленные типы явок

        :param include_deleted: Включать ли удаленные элементы в результат
        :type include_deleted: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_types_get_serialize(
            include_deleted=include_deleted,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceTypesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_types_get_without_preload_content(
        self,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Включать ли удаленные элементы в результат")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить типы явок

        Возвращает все не удаленные типы явок

        :param include_deleted: Включать ли удаленные элементы в результат
        :type include_deleted: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_types_get_serialize(
            include_deleted=include_deleted,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceTypesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_types_get_serialize(
        self,
        include_deleted,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include_deleted is not None:
            
            _query_params.append(('includeDeleted', include_deleted))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/attendance/types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_attendance_update_post(
        self,
        attendance_xml: AttendanceXml,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttendanceXml:
        """Обновить явку

        Обновление существующей явки. При обновлении (update) явки ее id может измениться.

        :param attendance_xml: (required)
        :type attendance_xml: AttendanceXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_update_post_serialize(
            attendance_xml=attendance_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_attendance_update_post_with_http_info(
        self,
        attendance_xml: AttendanceXml,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttendanceXml]:
        """Обновить явку

        Обновление существующей явки. При обновлении (update) явки ее id может измениться.

        :param attendance_xml: (required)
        :type attendance_xml: AttendanceXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_update_post_serialize(
            attendance_xml=attendance_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_attendance_update_post_without_preload_content(
        self,
        attendance_xml: AttendanceXml,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Обновить явку

        Обновление существующей явки. При обновлении (update) явки ее id может измениться.

        :param attendance_xml: (required)
        :type attendance_xml: AttendanceXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_attendance_update_post_serialize(
            attendance_xml=attendance_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttendanceXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_attendance_update_post_serialize(
        self,
        attendance_xml,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if attendance_xml is not None:
            _body_params = attendance_xml


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/employees/attendance/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_availability_list_get(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета (включающая) в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (исключающая) в формате YYYY-MM-DD")],
        department: Annotated[Optional[List[StrictStr]], Field(description="ID подразделения сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        role: Annotated[Optional[List[StrictStr]], Field(description="ID должности сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        user: Annotated[Optional[List[StrictStr]], Field(description="ID сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AvailabilitiesXml:
        """Получить доступность сотрудников

        Возвращает список отрезков доступности сотрудников. Отрезки доступности будут сформированы по расписаниям на весь запрошенный интервал.

        :param var_from: Дата начала отчета (включающая) в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (исключающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param department: ID подразделения сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type department: List[str]
        :param role: ID должности сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type role: List[str]
        :param user: ID сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type user: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_availability_list_get_serialize(
            var_from=var_from,
            to=to,
            department=department,
            role=role,
            user=user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AvailabilitiesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_availability_list_get_with_http_info(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета (включающая) в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (исключающая) в формате YYYY-MM-DD")],
        department: Annotated[Optional[List[StrictStr]], Field(description="ID подразделения сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        role: Annotated[Optional[List[StrictStr]], Field(description="ID должности сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        user: Annotated[Optional[List[StrictStr]], Field(description="ID сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AvailabilitiesXml]:
        """Получить доступность сотрудников

        Возвращает список отрезков доступности сотрудников. Отрезки доступности будут сформированы по расписаниям на весь запрошенный интервал.

        :param var_from: Дата начала отчета (включающая) в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (исключающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param department: ID подразделения сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type department: List[str]
        :param role: ID должности сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type role: List[str]
        :param user: ID сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type user: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_availability_list_get_serialize(
            var_from=var_from,
            to=to,
            department=department,
            role=role,
            user=user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AvailabilitiesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_availability_list_get_without_preload_content(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета (включающая) в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (исключающая) в формате YYYY-MM-DD")],
        department: Annotated[Optional[List[StrictStr]], Field(description="ID подразделения сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        role: Annotated[Optional[List[StrictStr]], Field(description="ID должности сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        user: Annotated[Optional[List[StrictStr]], Field(description="ID сотрудника для фильтрации. Можно задать параметр несколько раз.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить доступность сотрудников

        Возвращает список отрезков доступности сотрудников. Отрезки доступности будут сформированы по расписаниям на весь запрошенный интервал.

        :param var_from: Дата начала отчета (включающая) в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (исключающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param department: ID подразделения сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type department: List[str]
        :param role: ID должности сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type role: List[str]
        :param user: ID сотрудника для фильтрации. Можно задать параметр несколько раз.
        :type user: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_availability_list_get_serialize(
            var_from=var_from,
            to=to,
            department=department,
            role=role,
            user=user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AvailabilitiesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_availability_list_get_serialize(
        self,
        var_from,
        to,
        department,
        role,
        user,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'department': 'multi',
            'role': 'multi',
            'user': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if department is not None:
            
            _query_params.append(('department', department))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if user is not None:
            
            _query_params.append(('user', user))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/availability/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_by_code_employee_code_get(
        self,
        employee_code: Annotated[StrictStr, Field(description="Табельный номер сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeesXml:
        """Сотрудник по коду

        Получение сотрудника по табельному номеру

        :param employee_code: Табельный номер сотрудника (required)
        :type employee_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_code_employee_code_get_serialize(
            employee_code=employee_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_by_code_employee_code_get_with_http_info(
        self,
        employee_code: Annotated[StrictStr, Field(description="Табельный номер сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeesXml]:
        """Сотрудник по коду

        Получение сотрудника по табельному номеру

        :param employee_code: Табельный номер сотрудника (required)
        :type employee_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_code_employee_code_get_serialize(
            employee_code=employee_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_by_code_employee_code_get_without_preload_content(
        self,
        employee_code: Annotated[StrictStr, Field(description="Табельный номер сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Сотрудник по коду

        Получение сотрудника по табельному номеру

        :param employee_code: Табельный номер сотрудника (required)
        :type employee_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_code_employee_code_get_serialize(
            employee_code=employee_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_by_code_employee_code_get_serialize(
        self,
        employee_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_code is not None:
            _path_params['employeeCode'] = employee_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/byCode/{employeeCode}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_by_code_employee_code_put(
        self,
        employee_code: Annotated[StrictStr, Field(description="Табельный номер сотрудника")],
        employee_xml: Annotated[EmployeeXml, Field(description="Данные сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeXml:
        """Добавить сотрудника (по коду)

        Новый сотрудник (код возврата 201 Created). Примечание: учитывается только код, переданный в теле PUT-запроса.

        :param employee_code: Табельный номер сотрудника (required)
        :type employee_code: str
        :param employee_xml: Данные сотрудника (required)
        :type employee_xml: EmployeeXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_code_employee_code_put_serialize(
            employee_code=employee_code,
            employee_xml=employee_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_by_code_employee_code_put_with_http_info(
        self,
        employee_code: Annotated[StrictStr, Field(description="Табельный номер сотрудника")],
        employee_xml: Annotated[EmployeeXml, Field(description="Данные сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeXml]:
        """Добавить сотрудника (по коду)

        Новый сотрудник (код возврата 201 Created). Примечание: учитывается только код, переданный в теле PUT-запроса.

        :param employee_code: Табельный номер сотрудника (required)
        :type employee_code: str
        :param employee_xml: Данные сотрудника (required)
        :type employee_xml: EmployeeXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_code_employee_code_put_serialize(
            employee_code=employee_code,
            employee_xml=employee_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_by_code_employee_code_put_without_preload_content(
        self,
        employee_code: Annotated[StrictStr, Field(description="Табельный номер сотрудника")],
        employee_xml: Annotated[EmployeeXml, Field(description="Данные сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Добавить сотрудника (по коду)

        Новый сотрудник (код возврата 201 Created). Примечание: учитывается только код, переданный в теле PUT-запроса.

        :param employee_code: Табельный номер сотрудника (required)
        :type employee_code: str
        :param employee_xml: Данные сотрудника (required)
        :type employee_xml: EmployeeXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_code_employee_code_put_serialize(
            employee_code=employee_code,
            employee_xml=employee_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_by_code_employee_code_put_serialize(
        self,
        employee_code,
        employee_xml,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_code is not None:
            _path_params['employeeCode'] = employee_code
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if employee_xml is not None:
            _body_params = employee_xml


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/employees/byCode/{employeeCode}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_by_department_department_code_get(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeesXml:
        """Список сотрудников по подразделению

        Все сотрудники (включая встроенные системные аккаунты), которые активны (не удалены) в указанном подразделении

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_department_department_code_get_serialize(
            department_code=department_code,
            include_deleted=include_deleted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_by_department_department_code_get_with_http_info(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeesXml]:
        """Список сотрудников по подразделению

        Все сотрудники (включая встроенные системные аккаунты), которые активны (не удалены) в указанном подразделении

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_department_department_code_get_serialize(
            department_code=department_code,
            include_deleted=include_deleted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_by_department_department_code_get_without_preload_content(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Список сотрудников по подразделению

        Все сотрудники (включая встроенные системные аккаунты), которые активны (не удалены) в указанном подразделении

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_department_department_code_get_serialize(
            department_code=department_code,
            include_deleted=include_deleted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_by_department_department_code_get_serialize(
        self,
        department_code,
        include_deleted,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_code is not None:
            _path_params['departmentCode'] = department_code
        # process the query parameters
        if include_deleted is not None:
            
            _query_params.append(('includeDeleted', include_deleted))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/byDepartment/{departmentCode}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_by_id_employee_uuid_delete(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Удалить сотрудника

        Пустой ответ если сотрудник удален (или уже был удален). Entity of class User not found by id (employeeUUID), если передан несуществующий guid

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_delete_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "str",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_by_id_employee_uuid_delete_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Удалить сотрудника

        Пустой ответ если сотрудник удален (или уже был удален). Entity of class User not found by id (employeeUUID), если передан несуществующий guid

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_delete_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "str",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_by_id_employee_uuid_delete_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Удалить сотрудника

        Пустой ответ если сотрудник удален (или уже был удален). Entity of class User not found by id (employeeUUID), если передан несуществующий guid

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_delete_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': "str",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_by_id_employee_uuid_delete_serialize(
        self,
        employee_uuid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/employees/byId/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_by_id_employee_uuid_get(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeXml:
        """Сотрудник по ID

        Получение сотрудника по UUID

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_by_id_employee_uuid_get_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeXml]:
        """Сотрудник по ID

        Получение сотрудника по UUID

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_by_id_employee_uuid_get_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Сотрудник по ID

        Получение сотрудника по UUID

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_by_id_employee_uuid_get_serialize(
        self,
        employee_uuid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/byId/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_by_id_employee_uuid_post(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        code: Annotated[Optional[StrictStr], Field(description="Табельный номер сотрудника")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Имя сотрудника")] = None,
        login: Annotated[Optional[StrictStr], Field(description="Логин для входа в бекофис")] = None,
        password: Annotated[Optional[StrictStr], Field(description="Пароль для входа в бекофис")] = None,
        main_role_code: Annotated[Optional[StrictStr], Field(description="Код основной должности")] = None,
        role_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды должностей")] = None,
        phone: Annotated[Optional[StrictStr], Field(description="Телефон")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="Мобильный телефон")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Имя")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="Отчество")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Фамилия")] = None,
        birthday: Annotated[Optional[datetime], Field(description="Дата рождения")] = None,
        email: Annotated[Optional[StrictStr], Field(description="Email")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Адрес")] = None,
        hire_date: Annotated[Optional[StrictStr], Field(description="Дата найма")] = None,
        fire_date: Annotated[Optional[date], Field(description="Дата увольнения")] = None,
        note: Annotated[Optional[StrictStr], Field(description="Примечание")] = None,
        card_number: Annotated[Optional[StrictStr], Field(description="Slip карты сотрудника")] = None,
        pin_code: Annotated[Optional[StrictStr], Field(description="Pin-код для входа в iikoFront")] = None,
        taxpayer_id_number: Annotated[Optional[StrictStr], Field(description="ИНН")] = None,
        snils: Annotated[Optional[StrictStr], Field(description="СНИЛС")] = None,
        gln: Annotated[Optional[StrictStr], Field(description="Global Location Number для поставщиков")] = None,
        preferred_department_code: Annotated[Optional[StrictStr], Field(description="Код предпочитаемого подразделения")] = None,
        department_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды назначенных подразделений")] = None,
        responsibility_department_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды подразделений, где сотрудник является ответственным")] = None,
        deleted: Annotated[Optional[StrictBool], Field(description="Признак удаления")] = None,
        supplier: Annotated[Optional[StrictBool], Field(description="Признак поставщика")] = None,
        employee: Annotated[Optional[StrictBool], Field(description="Признак сотрудника")] = None,
        client: Annotated[Optional[StrictBool], Field(description="Признак клиента")] = None,
        external_data: Annotated[Optional[StrictStr], Field(description="Произвольные данные в XML формате")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeXml:
        """Изменить/добавить сотрудника (по id)

        Если передан новый id, то будет создан новый сотрудник (код возврата 201 Created). Если передан id существующего сотрудника, то произойдет изменение указанных полей (код возврата 200 OK). Поля не указанные в запросе останутся без изменений.

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param code: Табельный номер сотрудника
        :type code: str
        :param name: Имя сотрудника
        :type name: str
        :param login: Логин для входа в бекофис
        :type login: str
        :param password: Пароль для входа в бекофис
        :type password: str
        :param main_role_code: Код основной должности
        :type main_role_code: str
        :param role_codes: Коды должностей
        :type role_codes: List[str]
        :param phone: Телефон
        :type phone: str
        :param cell_phone: Мобильный телефон
        :type cell_phone: str
        :param first_name: Имя
        :type first_name: str
        :param middle_name: Отчество
        :type middle_name: str
        :param last_name: Фамилия
        :type last_name: str
        :param birthday: Дата рождения
        :type birthday: datetime
        :param email: Email
        :type email: str
        :param address: Адрес
        :type address: str
        :param hire_date: Дата найма
        :type hire_date: str
        :param fire_date: Дата увольнения
        :type fire_date: date
        :param note: Примечание
        :type note: str
        :param card_number: Slip карты сотрудника
        :type card_number: str
        :param pin_code: Pin-код для входа в iikoFront
        :type pin_code: str
        :param taxpayer_id_number: ИНН
        :type taxpayer_id_number: str
        :param snils: СНИЛС
        :type snils: str
        :param gln: Global Location Number для поставщиков
        :type gln: str
        :param preferred_department_code: Код предпочитаемого подразделения
        :type preferred_department_code: str
        :param department_codes: Коды назначенных подразделений
        :type department_codes: List[str]
        :param responsibility_department_codes: Коды подразделений, где сотрудник является ответственным
        :type responsibility_department_codes: List[str]
        :param deleted: Признак удаления
        :type deleted: bool
        :param supplier: Признак поставщика
        :type supplier: bool
        :param employee: Признак сотрудника
        :type employee: bool
        :param client: Признак клиента
        :type client: bool
        :param external_data: Произвольные данные в XML формате
        :type external_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_post_serialize(
            employee_uuid=employee_uuid,
            code=code,
            name=name,
            login=login,
            password=password,
            main_role_code=main_role_code,
            role_codes=role_codes,
            phone=phone,
            cell_phone=cell_phone,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            birthday=birthday,
            email=email,
            address=address,
            hire_date=hire_date,
            fire_date=fire_date,
            note=note,
            card_number=card_number,
            pin_code=pin_code,
            taxpayer_id_number=taxpayer_id_number,
            snils=snils,
            gln=gln,
            preferred_department_code=preferred_department_code,
            department_codes=department_codes,
            responsibility_department_codes=responsibility_department_codes,
            deleted=deleted,
            supplier=supplier,
            employee=employee,
            client=client,
            external_data=external_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_by_id_employee_uuid_post_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        code: Annotated[Optional[StrictStr], Field(description="Табельный номер сотрудника")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Имя сотрудника")] = None,
        login: Annotated[Optional[StrictStr], Field(description="Логин для входа в бекофис")] = None,
        password: Annotated[Optional[StrictStr], Field(description="Пароль для входа в бекофис")] = None,
        main_role_code: Annotated[Optional[StrictStr], Field(description="Код основной должности")] = None,
        role_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды должностей")] = None,
        phone: Annotated[Optional[StrictStr], Field(description="Телефон")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="Мобильный телефон")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Имя")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="Отчество")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Фамилия")] = None,
        birthday: Annotated[Optional[datetime], Field(description="Дата рождения")] = None,
        email: Annotated[Optional[StrictStr], Field(description="Email")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Адрес")] = None,
        hire_date: Annotated[Optional[StrictStr], Field(description="Дата найма")] = None,
        fire_date: Annotated[Optional[date], Field(description="Дата увольнения")] = None,
        note: Annotated[Optional[StrictStr], Field(description="Примечание")] = None,
        card_number: Annotated[Optional[StrictStr], Field(description="Slip карты сотрудника")] = None,
        pin_code: Annotated[Optional[StrictStr], Field(description="Pin-код для входа в iikoFront")] = None,
        taxpayer_id_number: Annotated[Optional[StrictStr], Field(description="ИНН")] = None,
        snils: Annotated[Optional[StrictStr], Field(description="СНИЛС")] = None,
        gln: Annotated[Optional[StrictStr], Field(description="Global Location Number для поставщиков")] = None,
        preferred_department_code: Annotated[Optional[StrictStr], Field(description="Код предпочитаемого подразделения")] = None,
        department_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды назначенных подразделений")] = None,
        responsibility_department_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды подразделений, где сотрудник является ответственным")] = None,
        deleted: Annotated[Optional[StrictBool], Field(description="Признак удаления")] = None,
        supplier: Annotated[Optional[StrictBool], Field(description="Признак поставщика")] = None,
        employee: Annotated[Optional[StrictBool], Field(description="Признак сотрудника")] = None,
        client: Annotated[Optional[StrictBool], Field(description="Признак клиента")] = None,
        external_data: Annotated[Optional[StrictStr], Field(description="Произвольные данные в XML формате")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeXml]:
        """Изменить/добавить сотрудника (по id)

        Если передан новый id, то будет создан новый сотрудник (код возврата 201 Created). Если передан id существующего сотрудника, то произойдет изменение указанных полей (код возврата 200 OK). Поля не указанные в запросе останутся без изменений.

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param code: Табельный номер сотрудника
        :type code: str
        :param name: Имя сотрудника
        :type name: str
        :param login: Логин для входа в бекофис
        :type login: str
        :param password: Пароль для входа в бекофис
        :type password: str
        :param main_role_code: Код основной должности
        :type main_role_code: str
        :param role_codes: Коды должностей
        :type role_codes: List[str]
        :param phone: Телефон
        :type phone: str
        :param cell_phone: Мобильный телефон
        :type cell_phone: str
        :param first_name: Имя
        :type first_name: str
        :param middle_name: Отчество
        :type middle_name: str
        :param last_name: Фамилия
        :type last_name: str
        :param birthday: Дата рождения
        :type birthday: datetime
        :param email: Email
        :type email: str
        :param address: Адрес
        :type address: str
        :param hire_date: Дата найма
        :type hire_date: str
        :param fire_date: Дата увольнения
        :type fire_date: date
        :param note: Примечание
        :type note: str
        :param card_number: Slip карты сотрудника
        :type card_number: str
        :param pin_code: Pin-код для входа в iikoFront
        :type pin_code: str
        :param taxpayer_id_number: ИНН
        :type taxpayer_id_number: str
        :param snils: СНИЛС
        :type snils: str
        :param gln: Global Location Number для поставщиков
        :type gln: str
        :param preferred_department_code: Код предпочитаемого подразделения
        :type preferred_department_code: str
        :param department_codes: Коды назначенных подразделений
        :type department_codes: List[str]
        :param responsibility_department_codes: Коды подразделений, где сотрудник является ответственным
        :type responsibility_department_codes: List[str]
        :param deleted: Признак удаления
        :type deleted: bool
        :param supplier: Признак поставщика
        :type supplier: bool
        :param employee: Признак сотрудника
        :type employee: bool
        :param client: Признак клиента
        :type client: bool
        :param external_data: Произвольные данные в XML формате
        :type external_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_post_serialize(
            employee_uuid=employee_uuid,
            code=code,
            name=name,
            login=login,
            password=password,
            main_role_code=main_role_code,
            role_codes=role_codes,
            phone=phone,
            cell_phone=cell_phone,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            birthday=birthday,
            email=email,
            address=address,
            hire_date=hire_date,
            fire_date=fire_date,
            note=note,
            card_number=card_number,
            pin_code=pin_code,
            taxpayer_id_number=taxpayer_id_number,
            snils=snils,
            gln=gln,
            preferred_department_code=preferred_department_code,
            department_codes=department_codes,
            responsibility_department_codes=responsibility_department_codes,
            deleted=deleted,
            supplier=supplier,
            employee=employee,
            client=client,
            external_data=external_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_by_id_employee_uuid_post_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        code: Annotated[Optional[StrictStr], Field(description="Табельный номер сотрудника")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Имя сотрудника")] = None,
        login: Annotated[Optional[StrictStr], Field(description="Логин для входа в бекофис")] = None,
        password: Annotated[Optional[StrictStr], Field(description="Пароль для входа в бекофис")] = None,
        main_role_code: Annotated[Optional[StrictStr], Field(description="Код основной должности")] = None,
        role_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды должностей")] = None,
        phone: Annotated[Optional[StrictStr], Field(description="Телефон")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="Мобильный телефон")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Имя")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="Отчество")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Фамилия")] = None,
        birthday: Annotated[Optional[datetime], Field(description="Дата рождения")] = None,
        email: Annotated[Optional[StrictStr], Field(description="Email")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Адрес")] = None,
        hire_date: Annotated[Optional[StrictStr], Field(description="Дата найма")] = None,
        fire_date: Annotated[Optional[date], Field(description="Дата увольнения")] = None,
        note: Annotated[Optional[StrictStr], Field(description="Примечание")] = None,
        card_number: Annotated[Optional[StrictStr], Field(description="Slip карты сотрудника")] = None,
        pin_code: Annotated[Optional[StrictStr], Field(description="Pin-код для входа в iikoFront")] = None,
        taxpayer_id_number: Annotated[Optional[StrictStr], Field(description="ИНН")] = None,
        snils: Annotated[Optional[StrictStr], Field(description="СНИЛС")] = None,
        gln: Annotated[Optional[StrictStr], Field(description="Global Location Number для поставщиков")] = None,
        preferred_department_code: Annotated[Optional[StrictStr], Field(description="Код предпочитаемого подразделения")] = None,
        department_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды назначенных подразделений")] = None,
        responsibility_department_codes: Annotated[Optional[List[StrictStr]], Field(description="Коды подразделений, где сотрудник является ответственным")] = None,
        deleted: Annotated[Optional[StrictBool], Field(description="Признак удаления")] = None,
        supplier: Annotated[Optional[StrictBool], Field(description="Признак поставщика")] = None,
        employee: Annotated[Optional[StrictBool], Field(description="Признак сотрудника")] = None,
        client: Annotated[Optional[StrictBool], Field(description="Признак клиента")] = None,
        external_data: Annotated[Optional[StrictStr], Field(description="Произвольные данные в XML формате")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Изменить/добавить сотрудника (по id)

        Если передан новый id, то будет создан новый сотрудник (код возврата 201 Created). Если передан id существующего сотрудника, то произойдет изменение указанных полей (код возврата 200 OK). Поля не указанные в запросе останутся без изменений.

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param code: Табельный номер сотрудника
        :type code: str
        :param name: Имя сотрудника
        :type name: str
        :param login: Логин для входа в бекофис
        :type login: str
        :param password: Пароль для входа в бекофис
        :type password: str
        :param main_role_code: Код основной должности
        :type main_role_code: str
        :param role_codes: Коды должностей
        :type role_codes: List[str]
        :param phone: Телефон
        :type phone: str
        :param cell_phone: Мобильный телефон
        :type cell_phone: str
        :param first_name: Имя
        :type first_name: str
        :param middle_name: Отчество
        :type middle_name: str
        :param last_name: Фамилия
        :type last_name: str
        :param birthday: Дата рождения
        :type birthday: datetime
        :param email: Email
        :type email: str
        :param address: Адрес
        :type address: str
        :param hire_date: Дата найма
        :type hire_date: str
        :param fire_date: Дата увольнения
        :type fire_date: date
        :param note: Примечание
        :type note: str
        :param card_number: Slip карты сотрудника
        :type card_number: str
        :param pin_code: Pin-код для входа в iikoFront
        :type pin_code: str
        :param taxpayer_id_number: ИНН
        :type taxpayer_id_number: str
        :param snils: СНИЛС
        :type snils: str
        :param gln: Global Location Number для поставщиков
        :type gln: str
        :param preferred_department_code: Код предпочитаемого подразделения
        :type preferred_department_code: str
        :param department_codes: Коды назначенных подразделений
        :type department_codes: List[str]
        :param responsibility_department_codes: Коды подразделений, где сотрудник является ответственным
        :type responsibility_department_codes: List[str]
        :param deleted: Признак удаления
        :type deleted: bool
        :param supplier: Признак поставщика
        :type supplier: bool
        :param employee: Признак сотрудника
        :type employee: bool
        :param client: Признак клиента
        :type client: bool
        :param external_data: Произвольные данные в XML формате
        :type external_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_post_serialize(
            employee_uuid=employee_uuid,
            code=code,
            name=name,
            login=login,
            password=password,
            main_role_code=main_role_code,
            role_codes=role_codes,
            phone=phone,
            cell_phone=cell_phone,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            birthday=birthday,
            email=email,
            address=address,
            hire_date=hire_date,
            fire_date=fire_date,
            note=note,
            card_number=card_number,
            pin_code=pin_code,
            taxpayer_id_number=taxpayer_id_number,
            snils=snils,
            gln=gln,
            preferred_department_code=preferred_department_code,
            department_codes=department_codes,
            responsibility_department_codes=responsibility_department_codes,
            deleted=deleted,
            supplier=supplier,
            employee=employee,
            client=client,
            external_data=external_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_by_id_employee_uuid_post_serialize(
        self,
        employee_uuid,
        code,
        name,
        login,
        password,
        main_role_code,
        role_codes,
        phone,
        cell_phone,
        first_name,
        middle_name,
        last_name,
        birthday,
        email,
        address,
        hire_date,
        fire_date,
        note,
        card_number,
        pin_code,
        taxpayer_id_number,
        snils,
        gln,
        preferred_department_code,
        department_codes,
        responsibility_department_codes,
        deleted,
        supplier,
        employee,
        client,
        external_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'roleCodes': 'csv',
            'departmentCodes': 'csv',
            'responsibilityDepartmentCodes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if code is not None:
            _form_params.append(('code', code))
        if name is not None:
            _form_params.append(('name', name))
        if login is not None:
            _form_params.append(('login', login))
        if password is not None:
            _form_params.append(('password', password))
        if main_role_code is not None:
            _form_params.append(('mainRoleCode', main_role_code))
        if role_codes is not None:
            _form_params.append(('roleCodes', role_codes))
        if phone is not None:
            _form_params.append(('phone', phone))
        if cell_phone is not None:
            _form_params.append(('cellPhone', cell_phone))
        if first_name is not None:
            _form_params.append(('firstName', first_name))
        if middle_name is not None:
            _form_params.append(('middleName', middle_name))
        if last_name is not None:
            _form_params.append(('lastName', last_name))
        if birthday is not None:
            _form_params.append(('birthday', birthday))
        if email is not None:
            _form_params.append(('email', email))
        if address is not None:
            _form_params.append(('address', address))
        if hire_date is not None:
            _form_params.append(('hireDate', hire_date))
        if fire_date is not None:
            _form_params.append(('fireDate', fire_date))
        if note is not None:
            _form_params.append(('note', note))
        if card_number is not None:
            _form_params.append(('cardNumber', card_number))
        if pin_code is not None:
            _form_params.append(('pinCode', pin_code))
        if taxpayer_id_number is not None:
            _form_params.append(('taxpayerIdNumber', taxpayer_id_number))
        if snils is not None:
            _form_params.append(('snils', snils))
        if gln is not None:
            _form_params.append(('gln', gln))
        if preferred_department_code is not None:
            _form_params.append(('preferredDepartmentCode', preferred_department_code))
        if department_codes is not None:
            _form_params.append(('departmentCodes', department_codes))
        if responsibility_department_codes is not None:
            _form_params.append(('responsibilityDepartmentCodes', responsibility_department_codes))
        if deleted is not None:
            _form_params.append(('deleted', deleted))
        if supplier is not None:
            _form_params.append(('supplier', supplier))
        if employee is not None:
            _form_params.append(('employee', employee))
        if client is not None:
            _form_params.append(('client', client))
        if external_data is not None:
            _form_params.append(('externalData', external_data))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/employees/byId/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_by_id_employee_uuid_put(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        employee_xml: Annotated[EmployeeXml, Field(description="Данные сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeXml:
        """Добавить или заменить сотрудника (по Id)

        Если передан новый id, то будет создан новый сотрудник (код возврата 201 Created). Если передан id существующего сотрудника, то произойдет полное замещение всех полей сотрудника (код возврата 200 OK).

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param employee_xml: Данные сотрудника (required)
        :type employee_xml: EmployeeXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_put_serialize(
            employee_uuid=employee_uuid,
            employee_xml=employee_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_by_id_employee_uuid_put_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        employee_xml: Annotated[EmployeeXml, Field(description="Данные сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeXml]:
        """Добавить или заменить сотрудника (по Id)

        Если передан новый id, то будет создан новый сотрудник (код возврата 201 Created). Если передан id существующего сотрудника, то произойдет полное замещение всех полей сотрудника (код возврата 200 OK).

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param employee_xml: Данные сотрудника (required)
        :type employee_xml: EmployeeXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_put_serialize(
            employee_uuid=employee_uuid,
            employee_xml=employee_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_by_id_employee_uuid_put_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="UUID сотрудника")],
        employee_xml: Annotated[EmployeeXml, Field(description="Данные сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Добавить или заменить сотрудника (по Id)

        Если передан новый id, то будет создан новый сотрудник (код возврата 201 Created). Если передан id существующего сотрудника, то произойдет полное замещение всех полей сотрудника (код возврата 200 OK).

        :param employee_uuid: UUID сотрудника (required)
        :type employee_uuid: str
        :param employee_xml: Данные сотрудника (required)
        :type employee_xml: EmployeeXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_by_id_employee_uuid_put_serialize(
            employee_uuid=employee_uuid,
            employee_xml=employee_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeXml",
            '201': "EmployeeXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_by_id_employee_uuid_put_serialize(
        self,
        employee_uuid,
        employee_xml,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if employee_xml is not None:
            _body_params = employee_xml


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/employees/byId/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_get(
        self,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeesXml:
        """Список активных сотрудников

        Все сотрудники (включая встроенные системные аккаунты), которые активны (не удалены)

        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_get_serialize(
            include_deleted=include_deleted,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_get_with_http_info(
        self,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeesXml]:
        """Список активных сотрудников

        Все сотрудники (включая встроенные системные аккаунты), которые активны (не удалены)

        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_get_serialize(
            include_deleted=include_deleted,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_get_without_preload_content(
        self,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Список активных сотрудников

        Все сотрудники (включая встроенные системные аккаунты), которые активны (не удалены)

        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_get_serialize(
            include_deleted=include_deleted,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_get_serialize(
        self,
        include_deleted,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include_deleted is not None:
            
            _query_params.append(('includeDeleted', include_deleted))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_roles_get(
        self,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeRolesXml:
        """Список должностей

        Получение списка должностей сотрудников

        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_roles_get_serialize(
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeRolesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_roles_get_with_http_info(
        self,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeRolesXml]:
        """Список должностей

        Получение списка должностей сотрудников

        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_roles_get_serialize(
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeRolesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_roles_get_without_preload_content(
        self,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Список должностей

        Получение списка должностей сотрудников

        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_roles_get_serialize(
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeRolesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_roles_get_serialize(
        self,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/roles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_salary_by_id_employee_uuid_date_get(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_date: Annotated[date, Field(description="Дата в формате YYYY-MM-DD")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeSalaryXml:
        """Оклад сотрудника на дату

        Получение оклада сотрудника на определенную дату

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_date: Дата в формате YYYY-MM-DD (required)
        :type var_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_date_get_serialize(
            employee_uuid=employee_uuid,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_salary_by_id_employee_uuid_date_get_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_date: Annotated[date, Field(description="Дата в формате YYYY-MM-DD")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeSalaryXml]:
        """Оклад сотрудника на дату

        Получение оклада сотрудника на определенную дату

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_date: Дата в формате YYYY-MM-DD (required)
        :type var_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_date_get_serialize(
            employee_uuid=employee_uuid,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_salary_by_id_employee_uuid_date_get_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_date: Annotated[date, Field(description="Дата в формате YYYY-MM-DD")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Оклад сотрудника на дату

        Получение оклада сотрудника на определенную дату

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_date: Дата в формате YYYY-MM-DD (required)
        :type var_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_date_get_serialize(
            employee_uuid=employee_uuid,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_salary_by_id_employee_uuid_date_get_serialize(
        self,
        employee_uuid,
        var_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        if var_date is not None:
            _path_params['date'] = var_date
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/salary/byId/{employeeUUID}/{date}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_salary_by_id_employee_uuid_date_post(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_date: Annotated[date, Field(description="Дата начала действия оклада в формате YYYY-MM-DD")],
        payment: Annotated[Union[StrictFloat, StrictInt], Field(description="Сумма оклада")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeSalaryXml:
        """Установить оклад сотрудника

        Установка оклада сотрудника с определенной даты

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_date: Дата начала действия оклада в формате YYYY-MM-DD (required)
        :type var_date: date
        :param payment: Сумма оклада (required)
        :type payment: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_date_post_serialize(
            employee_uuid=employee_uuid,
            var_date=var_date,
            payment=payment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_salary_by_id_employee_uuid_date_post_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_date: Annotated[date, Field(description="Дата начала действия оклада в формате YYYY-MM-DD")],
        payment: Annotated[Union[StrictFloat, StrictInt], Field(description="Сумма оклада")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeSalaryXml]:
        """Установить оклад сотрудника

        Установка оклада сотрудника с определенной даты

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_date: Дата начала действия оклада в формате YYYY-MM-DD (required)
        :type var_date: date
        :param payment: Сумма оклада (required)
        :type payment: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_date_post_serialize(
            employee_uuid=employee_uuid,
            var_date=var_date,
            payment=payment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_salary_by_id_employee_uuid_date_post_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_date: Annotated[date, Field(description="Дата начала действия оклада в формате YYYY-MM-DD")],
        payment: Annotated[Union[StrictFloat, StrictInt], Field(description="Сумма оклада")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Установить оклад сотрудника

        Установка оклада сотрудника с определенной даты

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_date: Дата начала действия оклада в формате YYYY-MM-DD (required)
        :type var_date: date
        :param payment: Сумма оклада (required)
        :type payment: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_date_post_serialize(
            employee_uuid=employee_uuid,
            var_date=var_date,
            payment=payment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_salary_by_id_employee_uuid_date_post_serialize(
        self,
        employee_uuid,
        var_date,
        payment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        if var_date is not None:
            _path_params['date'] = var_date
        # process the query parameters
        if payment is not None:
            
            _query_params.append(('payment', payment))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/employees/salary/byId/{employeeUUID}/{date}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_salary_by_id_employee_uuid_get(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeSalaryXml:
        """Текущий оклад сотрудника

        Получение текущего оклада сотрудника по ID

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_salary_by_id_employee_uuid_get_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeSalaryXml]:
        """Текущий оклад сотрудника

        Получение текущего оклада сотрудника по ID

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_salary_by_id_employee_uuid_get_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Текущий оклад сотрудника

        Получение текущего оклада сотрудника по ID

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_by_id_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalaryXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_salary_by_id_employee_uuid_get_serialize(
        self,
        employee_uuid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/salary/byId/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_salary_get(
        self,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeSalariesXml:
        """Список окладов

        Получение списка окладов не удаленных сотрудников

        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_get_serialize(
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalariesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_salary_get_with_http_info(
        self,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeSalariesXml]:
        """Список окладов

        Получение списка окладов не удаленных сотрудников

        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_get_serialize(
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalariesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_salary_get_without_preload_content(
        self,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Список окладов

        Получение списка окладов не удаленных сотрудников

        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности. Не включающий саму ревизию, т.е. ревизия объекта > revisionFrom. По умолчанию (неревизионный запрос) revisionFrom = -1
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_salary_get_serialize(
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeSalariesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_salary_get_serialize(
        self,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/salary',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_by_department_department_code_by_employee_employee_uuid_get(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchedulesXml:
        """Получить смены по подразделению и сотруднику

        Возвращаются все смены сотрудника в подразделении, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_department_department_code_by_employee_employee_uuid_get_serialize(
            department_code=department_code,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_by_department_department_code_by_employee_employee_uuid_get_with_http_info(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchedulesXml]:
        """Получить смены по подразделению и сотруднику

        Возвращаются все смены сотрудника в подразделении, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_department_department_code_by_employee_employee_uuid_get_serialize(
            department_code=department_code,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_by_department_department_code_by_employee_employee_uuid_get_without_preload_content(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить смены по подразделению и сотруднику

        Возвращаются все смены сотрудника в подразделении, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_department_department_code_by_employee_employee_uuid_get_serialize(
            department_code=department_code,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_by_department_department_code_by_employee_employee_uuid_get_serialize(
        self,
        department_code,
        employee_uuid,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_code is not None:
            _path_params['departmentCode'] = department_code
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/schedule/byDepartment/{departmentCode}/byEmployee/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_by_department_department_code_get(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchedulesXml:
        """Получить смены по подразделению

        Возвращаются все смены подразделения, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_department_department_code_get_serialize(
            department_code=department_code,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_by_department_department_code_get_with_http_info(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchedulesXml]:
        """Получить смены по подразделению

        Возвращаются все смены подразделения, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_department_department_code_get_serialize(
            department_code=department_code,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_by_department_department_code_get_without_preload_content(
        self,
        department_code: Annotated[StrictStr, Field(description="Код подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить смены по подразделению

        Возвращаются все смены подразделения, пересекающие интервал отчета

        :param department_code: Код подразделения (required)
        :type department_code: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_department_department_code_get_serialize(
            department_code=department_code,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_by_department_department_code_get_serialize(
        self,
        department_code,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_code is not None:
            _path_params['departmentCode'] = department_code
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/schedule/byDepartment/{departmentCode}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_by_employee_employee_uuid_get(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchedulesXml:
        """Получить смены по сотруднику

        Возвращаются все смены сотрудника, пересекающие интервал отчета

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_employee_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_by_employee_employee_uuid_get_with_http_info(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchedulesXml]:
        """Получить смены по сотруднику

        Возвращаются все смены сотрудника, пересекающие интервал отчета

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_employee_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_by_employee_employee_uuid_get_without_preload_content(
        self,
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить смены по сотруднику

        Возвращаются все смены сотрудника, пересекающие интервал отчета

        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_employee_employee_uuid_get_serialize(
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_by_employee_employee_uuid_get_serialize(
        self,
        employee_uuid,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/schedule/byEmployee/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_by_id_schedule_uuid_delete(
        self,
        schedule_uuid: Annotated[StrictStr, Field(description="Идентификатор смены")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduleXml:
        """Удалить смену

        Удаление смены по идентификатору

        :param schedule_uuid: Идентификатор смены (required)
        :type schedule_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_id_schedule_uuid_delete_serialize(
            schedule_uuid=schedule_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_by_id_schedule_uuid_delete_with_http_info(
        self,
        schedule_uuid: Annotated[StrictStr, Field(description="Идентификатор смены")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduleXml]:
        """Удалить смену

        Удаление смены по идентификатору

        :param schedule_uuid: Идентификатор смены (required)
        :type schedule_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_id_schedule_uuid_delete_serialize(
            schedule_uuid=schedule_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_by_id_schedule_uuid_delete_without_preload_content(
        self,
        schedule_uuid: Annotated[StrictStr, Field(description="Идентификатор смены")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Удалить смену

        Удаление смены по идентификатору

        :param schedule_uuid: Идентификатор смены (required)
        :type schedule_uuid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_by_id_schedule_uuid_delete_serialize(
            schedule_uuid=schedule_uuid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_by_id_schedule_uuid_delete_serialize(
        self,
        schedule_uuid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if schedule_uuid is not None:
            _path_params['scheduleUUID'] = schedule_uuid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/employees/schedule/byId/{scheduleUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_create_post(
        self,
        schedule_xml: Annotated[ScheduleXml, Field(description="Данные смены для создания")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduleXml:
        """Создать смену

        Создание новой смены. При создании поле id может быть не заполнено. Даты округляются с точностью до минуты.

        :param schedule_xml: Данные смены для создания (required)
        :type schedule_xml: ScheduleXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_create_post_serialize(
            schedule_xml=schedule_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_create_post_with_http_info(
        self,
        schedule_xml: Annotated[ScheduleXml, Field(description="Данные смены для создания")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduleXml]:
        """Создать смену

        Создание новой смены. При создании поле id может быть не заполнено. Даты округляются с точностью до минуты.

        :param schedule_xml: Данные смены для создания (required)
        :type schedule_xml: ScheduleXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_create_post_serialize(
            schedule_xml=schedule_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_create_post_without_preload_content(
        self,
        schedule_xml: Annotated[ScheduleXml, Field(description="Данные смены для создания")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Создать смену

        Создание новой смены. При создании поле id может быть не заполнено. Даты округляются с точностью до минуты.

        :param schedule_xml: Данные смены для создания (required)
        :type schedule_xml: ScheduleXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_create_post_serialize(
            schedule_xml=schedule_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_create_post_serialize(
        self,
        schedule_xml,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if schedule_xml is not None:
            _body_params = schedule_xml


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/employees/schedule/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_department_department_id_by_employee_employee_uuid_get(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchedulesXml:
        """Получить смены по подразделению (по ID) и сотруднику

        Возвращаются все смены сотрудника в подразделении по UUID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_department_department_id_by_employee_employee_uuid_get_serialize(
            department_id=department_id,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_department_department_id_by_employee_employee_uuid_get_with_http_info(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchedulesXml]:
        """Получить смены по подразделению (по ID) и сотруднику

        Возвращаются все смены сотрудника в подразделении по UUID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_department_department_id_by_employee_employee_uuid_get_serialize(
            department_id=department_id,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_department_department_id_by_employee_employee_uuid_get_without_preload_content(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        employee_uuid: Annotated[StrictStr, Field(description="Идентификатор сотрудника")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить смены по подразделению (по ID) и сотруднику

        Возвращаются все смены сотрудника в подразделении по UUID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param employee_uuid: Идентификатор сотрудника (required)
        :type employee_uuid: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_department_department_id_by_employee_employee_uuid_get_serialize(
            department_id=department_id,
            employee_uuid=employee_uuid,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_department_department_id_by_employee_employee_uuid_get_serialize(
        self,
        department_id,
        employee_uuid,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_id is not None:
            _path_params['departmentId'] = department_id
        if employee_uuid is not None:
            _path_params['employeeUUID'] = employee_uuid
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/schedule/department/{departmentId}/byEmployee/{employeeUUID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_department_department_id_get(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchedulesXml:
        """Получить смены по подразделению (по ID)

        Возвращаются все смены подразделения по UUID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_department_department_id_get_serialize(
            department_id=department_id,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_department_department_id_get_with_http_info(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchedulesXml]:
        """Получить смены по подразделению (по ID)

        Возвращаются все смены подразделения по UUID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_department_department_id_get_serialize(
            department_id=department_id,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_department_department_id_get_without_preload_content(
        self,
        department_id: Annotated[StrictStr, Field(description="UUID идентификатор подразделения")],
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить смены по подразделению (по ID)

        Возвращаются все смены подразделения по UUID, пересекающие интервал отчета

        :param department_id: UUID идентификатор подразделения (required)
        :type department_id: str
        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_department_department_id_get_serialize(
            department_id=department_id,
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_department_department_id_get_serialize(
        self,
        department_id,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if department_id is not None:
            _path_params['departmentId'] = department_id
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/schedule/department/{departmentId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_get(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchedulesXml:
        """Получить смены

        Возвращаются все смены, пересекающие интервал отчета

        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_get_serialize(
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_get_with_http_info(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchedulesXml]:
        """Получить смены

        Возвращаются все смены, пересекающие интервал отчета

        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_get_serialize(
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_get_without_preload_content(
        self,
        var_from: Annotated[date, Field(description="Дата начала отчета в формате YYYY-MM-DD")],
        to: Annotated[date, Field(description="Дата окончания отчета (включающая) в формате YYYY-MM-DD")],
        with_payment_details: Annotated[Optional[StrictBool], Field(description="Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате")] = None,
        revision_from: Annotated[Optional[StrictInt], Field(description="Номер ревизии, начиная с которой необходимо отфильтровать сущности")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить смены

        Возвращаются все смены, пересекающие интервал отчета

        :param var_from: Дата начала отчета в формате YYYY-MM-DD (required)
        :type var_from: date
        :param to: Дата окончания отчета (включающая) в формате YYYY-MM-DD (required)
        :type to: date
        :param with_payment_details: Если true, ко сменам добавляется информация об отработанном времени и начисленной заработной плате
        :type with_payment_details: bool
        :param revision_from: Номер ревизии, начиная с которой необходимо отфильтровать сущности
        :type revision_from: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_get_serialize(
            var_from=var_from,
            to=to,
            with_payment_details=with_payment_details,
            revision_from=revision_from,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchedulesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_get_serialize(
        self,
        var_from,
        to,
        with_payment_details,
        revision_from,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if var_from is not None:
            if isinstance(var_from, date):
                _query_params.append(
                    (
                        'from',
                        var_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('from', var_from))
            
        if to is not None:
            if isinstance(to, date):
                _query_params.append(
                    (
                        'to',
                        to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('to', to))
            
        if with_payment_details is not None:
            
            _query_params.append(('withPaymentDetails', with_payment_details))
            
        if revision_from is not None:
            
            _query_params.append(('revisionFrom', revision_from))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/schedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_types_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduleTypesXml:
        """Получить типы смен

        Возвращаются все не удаленные типы смен

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_types_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleTypesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_types_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduleTypesXml]:
        """Получить типы смен

        Возвращаются все не удаленные типы смен

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_types_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleTypesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_types_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Получить типы смен

        Возвращаются все не удаленные типы смен

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_types_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleTypesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_types_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/schedule/types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_schedule_update_post(
        self,
        schedule_xml: Annotated[ScheduleXml, Field(description="Данные смены для обновления")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduleXml:
        """Обновить смену

        Обновление существующей смены. При обновлении id смены может измениться. Даты округляются с точностью до минуты.

        :param schedule_xml: Данные смены для обновления (required)
        :type schedule_xml: ScheduleXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_update_post_serialize(
            schedule_xml=schedule_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_schedule_update_post_with_http_info(
        self,
        schedule_xml: Annotated[ScheduleXml, Field(description="Данные смены для обновления")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduleXml]:
        """Обновить смену

        Обновление существующей смены. При обновлении id смены может измениться. Даты округляются с точностью до минуты.

        :param schedule_xml: Данные смены для обновления (required)
        :type schedule_xml: ScheduleXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_update_post_serialize(
            schedule_xml=schedule_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_schedule_update_post_without_preload_content(
        self,
        schedule_xml: Annotated[ScheduleXml, Field(description="Данные смены для обновления")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Обновить смену

        Обновление существующей смены. При обновлении id смены может измениться. Даты округляются с точностью до минуты.

        :param schedule_xml: Данные смены для обновления (required)
        :type schedule_xml: ScheduleXml
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_schedule_update_post_serialize(
            schedule_xml=schedule_xml,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduleXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_schedule_update_post_serialize(
        self,
        schedule_xml,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if schedule_xml is not None:
            _body_params = schedule_xml


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/employees/schedule/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def employees_search_get(
        self,
        first_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по имени")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по отчеству")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по фамилии")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по адресу")] = None,
        card_number: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по номеру карты")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по мобильному телефону")] = None,
        client: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку клиента")] = None,
        code: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по табельному номеру")] = None,
        email: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по email")] = None,
        employee: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку сотрудника")] = None,
        login: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по логину")] = None,
        main_role_code: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по коду основной должности")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по имени сотрудника")] = None,
        note: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по примечанию")] = None,
        phone: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по телефону")] = None,
        supplier: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку поставщика")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeesXml:
        """Поиск сотрудника

        Поиск сотрудника по различным полям с использованием регулярных выражений

        :param first_name: Регулярное выражение для поиска по имени
        :type first_name: str
        :param middle_name: Регулярное выражение для поиска по отчеству
        :type middle_name: str
        :param last_name: Регулярное выражение для поиска по фамилии
        :type last_name: str
        :param address: Регулярное выражение для поиска по адресу
        :type address: str
        :param card_number: Регулярное выражение для поиска по номеру карты
        :type card_number: str
        :param cell_phone: Регулярное выражение для поиска по мобильному телефону
        :type cell_phone: str
        :param client: Фильтр по признаку клиента
        :type client: bool
        :param code: Регулярное выражение для поиска по табельному номеру
        :type code: str
        :param email: Регулярное выражение для поиска по email
        :type email: str
        :param employee: Фильтр по признаку сотрудника
        :type employee: bool
        :param login: Регулярное выражение для поиска по логину
        :type login: str
        :param main_role_code: Регулярное выражение для поиска по коду основной должности
        :type main_role_code: str
        :param name: Регулярное выражение для поиска по имени сотрудника
        :type name: str
        :param note: Регулярное выражение для поиска по примечанию
        :type note: str
        :param phone: Регулярное выражение для поиска по телефону
        :type phone: str
        :param supplier: Фильтр по признаку поставщика
        :type supplier: bool
        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_search_get_serialize(
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            address=address,
            card_number=card_number,
            cell_phone=cell_phone,
            client=client,
            code=code,
            email=email,
            employee=employee,
            login=login,
            main_role_code=main_role_code,
            name=name,
            note=note,
            phone=phone,
            supplier=supplier,
            include_deleted=include_deleted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def employees_search_get_with_http_info(
        self,
        first_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по имени")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по отчеству")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по фамилии")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по адресу")] = None,
        card_number: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по номеру карты")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по мобильному телефону")] = None,
        client: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку клиента")] = None,
        code: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по табельному номеру")] = None,
        email: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по email")] = None,
        employee: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку сотрудника")] = None,
        login: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по логину")] = None,
        main_role_code: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по коду основной должности")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по имени сотрудника")] = None,
        note: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по примечанию")] = None,
        phone: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по телефону")] = None,
        supplier: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку поставщика")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeesXml]:
        """Поиск сотрудника

        Поиск сотрудника по различным полям с использованием регулярных выражений

        :param first_name: Регулярное выражение для поиска по имени
        :type first_name: str
        :param middle_name: Регулярное выражение для поиска по отчеству
        :type middle_name: str
        :param last_name: Регулярное выражение для поиска по фамилии
        :type last_name: str
        :param address: Регулярное выражение для поиска по адресу
        :type address: str
        :param card_number: Регулярное выражение для поиска по номеру карты
        :type card_number: str
        :param cell_phone: Регулярное выражение для поиска по мобильному телефону
        :type cell_phone: str
        :param client: Фильтр по признаку клиента
        :type client: bool
        :param code: Регулярное выражение для поиска по табельному номеру
        :type code: str
        :param email: Регулярное выражение для поиска по email
        :type email: str
        :param employee: Фильтр по признаку сотрудника
        :type employee: bool
        :param login: Регулярное выражение для поиска по логину
        :type login: str
        :param main_role_code: Регулярное выражение для поиска по коду основной должности
        :type main_role_code: str
        :param name: Регулярное выражение для поиска по имени сотрудника
        :type name: str
        :param note: Регулярное выражение для поиска по примечанию
        :type note: str
        :param phone: Регулярное выражение для поиска по телефону
        :type phone: str
        :param supplier: Фильтр по признаку поставщика
        :type supplier: bool
        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_search_get_serialize(
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            address=address,
            card_number=card_number,
            cell_phone=cell_phone,
            client=client,
            code=code,
            email=email,
            employee=employee,
            login=login,
            main_role_code=main_role_code,
            name=name,
            note=note,
            phone=phone,
            supplier=supplier,
            include_deleted=include_deleted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def employees_search_get_without_preload_content(
        self,
        first_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по имени")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по отчеству")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по фамилии")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по адресу")] = None,
        card_number: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по номеру карты")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по мобильному телефону")] = None,
        client: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку клиента")] = None,
        code: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по табельному номеру")] = None,
        email: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по email")] = None,
        employee: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку сотрудника")] = None,
        login: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по логину")] = None,
        main_role_code: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по коду основной должности")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по имени сотрудника")] = None,
        note: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по примечанию")] = None,
        phone: Annotated[Optional[StrictStr], Field(description="Регулярное выражение для поиска по телефону")] = None,
        supplier: Annotated[Optional[StrictBool], Field(description="Фильтр по признаку поставщика")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Возвращать и действующих, и удаленных сотрудников")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Поиск сотрудника

        Поиск сотрудника по различным полям с использованием регулярных выражений

        :param first_name: Регулярное выражение для поиска по имени
        :type first_name: str
        :param middle_name: Регулярное выражение для поиска по отчеству
        :type middle_name: str
        :param last_name: Регулярное выражение для поиска по фамилии
        :type last_name: str
        :param address: Регулярное выражение для поиска по адресу
        :type address: str
        :param card_number: Регулярное выражение для поиска по номеру карты
        :type card_number: str
        :param cell_phone: Регулярное выражение для поиска по мобильному телефону
        :type cell_phone: str
        :param client: Фильтр по признаку клиента
        :type client: bool
        :param code: Регулярное выражение для поиска по табельному номеру
        :type code: str
        :param email: Регулярное выражение для поиска по email
        :type email: str
        :param employee: Фильтр по признаку сотрудника
        :type employee: bool
        :param login: Регулярное выражение для поиска по логину
        :type login: str
        :param main_role_code: Регулярное выражение для поиска по коду основной должности
        :type main_role_code: str
        :param name: Регулярное выражение для поиска по имени сотрудника
        :type name: str
        :param note: Регулярное выражение для поиска по примечанию
        :type note: str
        :param phone: Регулярное выражение для поиска по телефону
        :type phone: str
        :param supplier: Фильтр по признаку поставщика
        :type supplier: bool
        :param include_deleted: Возвращать и действующих, и удаленных сотрудников
        :type include_deleted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._employees_search_get_serialize(
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            address=address,
            card_number=card_number,
            cell_phone=cell_phone,
            client=client,
            code=code,
            email=email,
            employee=employee,
            login=login,
            main_role_code=main_role_code,
            name=name,
            note=note,
            phone=phone,
            supplier=supplier,
            include_deleted=include_deleted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeesXml",
            '400': "str",
            '401': "str",
            '403': "str",
            '404': "str",
            '406': "str",
            '409': "str",
            '429': "str",
            '500': "str",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _employees_search_get_serialize(
        self,
        first_name,
        middle_name,
        last_name,
        address,
        card_number,
        cell_phone,
        client,
        code,
        email,
        employee,
        login,
        main_role_code,
        name,
        note,
        phone,
        supplier,
        include_deleted,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if first_name is not None:
            
            _query_params.append(('firstName', first_name))
            
        if middle_name is not None:
            
            _query_params.append(('middleName', middle_name))
            
        if last_name is not None:
            
            _query_params.append(('lastName', last_name))
            
        if address is not None:
            
            _query_params.append(('address', address))
            
        if card_number is not None:
            
            _query_params.append(('cardNumber', card_number))
            
        if cell_phone is not None:
            
            _query_params.append(('cellPhone', cell_phone))
            
        if client is not None:
            
            _query_params.append(('client', client))
            
        if code is not None:
            
            _query_params.append(('code', code))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if employee is not None:
            
            _query_params.append(('employee', employee))
            
        if login is not None:
            
            _query_params.append(('login', login))
            
        if main_role_code is not None:
            
            _query_params.append(('mainRoleCode', main_role_code))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if note is not None:
            
            _query_params.append(('note', note))
            
        if phone is not None:
            
            _query_params.append(('phone', phone))
            
        if supplier is not None:
            
            _query_params.append(('supplier', supplier))
            
        if include_deleted is not None:
            
            _query_params.append(('includeDeleted', include_deleted))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/xml', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'iikoCookieAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/employees/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


